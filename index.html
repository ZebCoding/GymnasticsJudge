<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gymnastics Judge AI - Pommel Horse/Mushroom</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 10px; text-align: center; background: #111; color: white; min-height: 100vh; }
    video { width: 100%; max-width: 480px; border: 2px solid #444; border-radius: 12px; margin: 5px; }
    canvas { display: none; }
    .video-container { display: flex; justify-content: center; align-items: flex-start; flex-wrap: wrap; gap: 10px; }
    .video-section { text-align: center; flex: 1; min-width: 280px; max-width: 500px; }
    .video-section h3 { margin: 5px 0; color: white; font-size: 1.1em; }
    .score { font-size: 2.5em; margin: 15px 0; font-weight: bold; color: #00ff00; }
    #poseStatus { font-size: 0.9em; margin: 10px 0; padding: 5px; }
    button { padding: 12px 20px; margin: 8px 5px; font-size: 1em; border: none; border-radius: 8px; background: #007BFF; color: white; min-width: 120px; }
    button:hover { background: #0056b3; }
    button:disabled { background: #555; }
    #replayStatus { font-size: 1em; margin: 10px 0; font-weight: bold; }
    
    /* Mobile optimizations */
    @media (max-width: 768px) {
      body { padding: 5px; }
      .score { font-size: 2em; margin: 10px 0; }
      .video-container { flex-direction: column; align-items: center; }
      .video-section { width: 100%; max-width: 100%; }
      video, #replayVideo { max-width: 100%; width: 95%; }
      button { padding: 15px 25px; margin: 10px 5px; font-size: 1.1em; min-width: 140px; }
      .video-section h3 { font-size: 1.2em; margin: 8px 0; }
      #poseStatus { font-size: 1em; padding: 8px; margin: 8px 0; }
      #replayStatus { font-size: 1.1em; margin: 12px 0; }
    }
    
    /* Very small screens */
    @media (max-width: 480px) {
      .score { font-size: 1.8em; }
      button { padding: 12px 20px; font-size: 1em; min-width: 120px; }
      .video-section h3 { font-size: 1em; }
    }
  </style>
  <!-- Load MediaPipe Pose -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</head>
<body>
  <h1>Gymnastics Judge AI - Pommel Horse</h1>
  <div class="video-container">
    <div class="video-section">
      <h3>Camera Feed</h3>
      <video id="camera" autoplay playsinline></video>
    </div>
  </div>
  
  <!-- Replay Video Section (hidden by default) -->
  <div id="replaySection" class="video-container" style="display: none; margin-top: 20px;">
    <div class="video-section">
      <h3>Routine Replay - Pausing at Deductions</h3>
      <video id="replayVideo" controls style="width: 100%; max-width: 640px; border: 2px solid #007BFF; border-radius: 12px;"></video>
      <div id="replayStatus" style="color: #ff9800; margin: 10px 0; font-weight: bold;">Replay starting in 3 seconds...</div>
      <button id="closeReplay" style="margin-top: 10px;">Close Replay & Ready for Next Routine</button>
    </div>
  </div>
  <div class="score">Score: <span id="score">10.0</span></div>
  <div id="poseStatus" style="color: #888; font-size: 0.9em; margin: 10px 0;">Pose: Not detecting</div>

  <button id="startRoutine">Ready for Routine</button>

  <script>
    const video = document.getElementById('camera');
    const scoreDisplay = document.getElementById('score');
    const poseStatus = document.getElementById('poseStatus');
    const replaySection = document.getElementById('replaySection');
    const replayVideo = document.getElementById('replayVideo');
    const replayStatus = document.getElementById('replayStatus');

    const startBtn = document.getElementById('startRoutine');
    const closeReplayBtn = document.getElementById('closeReplay');
    

    let score = 10.0;
    let mediaStream;
    let mediaRecorder;
    let recordedChunks = [];
    let routineStartTime = 0; // When routine actually started (for video timing)
    let recordedVideoBlob = null; // Store video for replay
    let deductionTimestamps = []; // Store when deductions occurred for replay pausing
    let mountingGracePeriod = 0; // Time when mounting grace period ends
    let routineStarted = false;
    
    // Routine state machine
    const ROUTINE_STATES = {
      WAITING: 'waiting',     // Before "Ready for Routine" clicked
      SETUP: 'setup',         // After button click, waiting for salute
      ACTIVE: 'active',       // After salute, routine in progress (deductions active)
      FINISHED: 'finished'    // After bow, routine complete (no more deductions)
    };
    let routineState = ROUTINE_STATES.WAITING;

    // Control repeated deductions: per-reason cooldown in milliseconds
    const DEDUCTION_COOLDOWN_MS = 1000; // 1 second cooldown
    let lastDeductionAt = {}; // reason -> timestamp (performance.now())
    
    // Detection loop monitoring
    let lastDetectionTime = 0;
    let detectionLoopRunning = false;
    let poseFailureCount = 0;
    const MAX_POSE_FAILURES = 10;
    
    // Frame rate limiting to prevent freezing
    let lastFrameTime = 0;
    const TARGET_FPS = 15; // Limit to 15fps for better stability
    const FRAME_INTERVAL = 1000 / TARGET_FPS;
    
    // Anti-freeze monitoring
    let consecutiveFailures = 0;
    let lastSuccessfulPose = 0;
    const MAX_FREEZE_TIME = 3000; // 3 seconds without pose updates = frozen
    const RESTART_THRESHOLD = 5; // Restart after 5 consecutive failures
    
    
    // Gesture detection
    let waitingForSalute = false;
    let waitingForBow = false;
    let gestureHoldFrames = 0; // Still used for salute
    const SALUTE_ARM_ANGLE_THRESHOLD = 45; // arms up angle
    
    // Salute detection - simplified to immediate trigger
    const SALUTE_CONFIRM_FRAMES = 5; // ~0.08 seconds to confirm salute

    // Get camera and start pose detection immediately
    navigator.mediaDevices.getUserMedia({ video: true })
      .then(stream => { 
        mediaStream = stream; 
        video.srcObject = stream;
        console.log('Camera stream obtained');
        
        // Start pose detection when video is ready
        video.addEventListener('loadeddata', () => {
          console.log('Video loaded, dimensions:', video.videoWidth, 'x', video.videoHeight);
          // Wait a moment for video to stabilize
          setTimeout(() => {
            console.log('Starting pose detection...');
            detectPose();
          }, 1000);
        });
      })
      .catch(err => { 
        console.error('Camera error:', err);
        alert('Camera not available: ' + err); 
      });

    // Utility functions
    function calculateAngle(A, B, C) {
      const AB = {x: B.x - A.x, y: B.y - A.y};
      const CB = {x: B.x - C.x, y: B.y - C.y};
      const dot = AB.x * CB.x + AB.y * CB.y;
      const magAB = Math.sqrt(AB.x*AB.x + AB.y*AB.y);
      const magCB = Math.sqrt(CB.x*CB.x + CB.y*CB.y);
      
      // Prevent division by zero or invalid angles
      if (magAB === 0 || magCB === 0) {
        console.log('Warning: Zero magnitude in angle calculation');
        return 180; // Return straight line angle as default
      }
      
      const cosAngle = dot / (magAB * magCB);
      // Clamp to valid range for acos to prevent NaN
      const clampedCos = Math.max(-1, Math.min(1, cosAngle));
      const angle = Math.acos(clampedCos) * (180/Math.PI);
      
      // Validate result
      if (isNaN(angle)) {
        console.log('Warning: NaN angle calculated, returning 180Â°');
        return 180;
      }
      
      return angle;
    }

    function distance(A, B) {
      return Math.sqrt((A.x - B.x)**2 + (A.y - B.y)**2);
    }
    
    function detectSalute(landmarks) {
      // One-arm salute detection with visibility + multiple cues
      const nose = landmarks[0];
      const leftShoulder = landmarks[11], rightShoulder = landmarks[12];
      const leftElbow = landmarks[13], rightElbow = landmarks[14];
      const leftWrist = landmarks[15], rightWrist = landmarks[16];
      
      if (!nose || !leftShoulder || !rightShoulder || !leftElbow || !rightElbow || !leftWrist || !rightWrist) return false;
      
      // Helper to validate landmark confidence
      const visOK = (lm) => lm.visibility === undefined || lm.visibility >= 0.5;
      if (![nose, leftShoulder, rightShoulder, leftElbow, rightElbow, leftWrist, rightWrist].every(visOK)) {
        return false;
      }
      
      // Consider an arm raised if wrist and elbow are above shoulder (y smaller = higher)
      // and optionally wrist near head level to be robust to different body sizes
      const leftRaised = (leftWrist.y < leftShoulder.y - 0.08 && leftElbow.y < leftShoulder.y - 0.04) || (leftWrist.y < (nose.y + 0.05));
      const rightRaised = (rightWrist.y < rightShoulder.y - 0.08 && rightElbow.y < rightShoulder.y - 0.04) || (rightWrist.y < (nose.y + 0.05));
      
      // Accept salute when at least one arm is raised
      return leftRaised || rightRaised;
    }
    
    function detectArmsDown(landmarks) {
      // Check if both arms are down (at sides)
      const leftShoulder = landmarks[11], rightShoulder = landmarks[12];
      const leftElbow = landmarks[13], rightElbow = landmarks[14];
      const leftWrist = landmarks[15], rightWrist = landmarks[16];
      
      if (!leftShoulder || !rightShoulder || !leftElbow || !rightElbow || !leftWrist || !rightWrist) return false;
      
      // Helper to validate landmark confidence
      const visOK = (lm) => lm.visibility === undefined || lm.visibility >= 0.5;
      if (![leftShoulder, rightShoulder, leftElbow, rightElbow, leftWrist, rightWrist].every(visOK)) {
        return false;
      }
      
      // Arms are down if both wrists are at or below shoulder level
      const leftArmDown = leftWrist.y >= leftShoulder.y - 0.05;
      const rightArmDown = rightWrist.y >= rightShoulder.y - 0.05;
      
      return leftArmDown && rightArmDown;
    }
    
    
    function detectBow(landmarks) {
      // Bow detection based on real bowing posture analysis
      const nose = landmarks[0];
      const leftShoulder = landmarks[11], rightShoulder = landmarks[12];
      const leftHip = landmarks[23], rightHip = landmarks[24];
      const leftElbow = landmarks[13], rightElbow = landmarks[14];
      const leftWrist = landmarks[15], rightWrist = landmarks[16];
      
      if (!nose || !leftShoulder || !rightShoulder || !leftHip || !rightHip) return false;
      
      // Helper to validate landmark confidence
      const visOK = (lm) => lm.visibility === undefined || lm.visibility >= 0.4;
      if (![nose, leftShoulder, rightShoulder, leftHip, rightHip].every(visOK)) {
        return false;
      }
      
      // Calculate positions
      const shoulderY = (leftShoulder.y + rightShoulder.y) / 2;
      const hipY = (leftHip.y + rightHip.y) / 2;
      
      // Simple bow detection: significant head drop + arms not reaching equipment
      const headDrop = nose.y - shoulderY;
      const bowingDown = headDrop > 0.04; // Head dropped below shoulders = bow
      
      // Only check: are arms reaching for equipment? If not, allow the bow
      let armsAtSides = true;
      if (leftWrist && rightWrist && leftElbow && rightElbow) {
        // Block only if clearly reaching down for equipment (very generous thresholds)
        const leftArmReaching = leftWrist.y > leftShoulder.y + 0.3; // Very generous
        const rightArmReaching = rightWrist.y > rightShoulder.y + 0.3;
        const leftElbowReaching = leftElbow.y > leftShoulder.y + 0.25;
        const rightElbowReaching = rightElbow.y > rightShoulder.y + 0.25;
        
        // Only block if BOTH arms AND elbows are reaching down significantly
        const obviousReaching = (leftArmReaching && leftElbowReaching) || (rightArmReaching && rightElbowReaching);
        armsAtSides = !obviousReaching;
      }
      
      // Bow detection: head down + not obviously reaching for equipment
      const bowDetected = bowingDown && armsAtSides;
      
      const finalBowDetection = bowDetected;
      
      // Debug bow detection - show every time when routine is active and waiting for bow
      if (routineState === ROUTINE_STATES.ACTIVE && waitingForBow) {
        console.log(`ð¹ BOW CHECK - Nose:${nose.y.toFixed(3)} Shoulder:${shoulderY.toFixed(3)}`);
        console.log(`Head drop: ${headDrop.toFixed(3)} (bowing down: ${headDrop.toFixed(3)} > 0.04 = ${bowingDown})`);
        console.log(`Arms at sides (not reaching equipment): ${armsAtSides}`);
        if (leftWrist && rightWrist && leftElbow && rightElbow) {
          console.log(`Arm positions - LWrist:${leftWrist.y.toFixed(3)} RWrist:${rightWrist.y.toFixed(3)} LElbow:${leftElbow.y.toFixed(3)} RElbow:${rightElbow.y.toFixed(3)}`);
          const leftArmReaching = leftWrist.y > leftShoulder.y + 0.3;
          const rightArmReaching = rightWrist.y > rightShoulder.y + 0.3;
          const leftElbowReaching = leftElbow.y > leftShoulder.y + 0.25;
          const rightElbowReaching = rightElbow.y > rightShoulder.y + 0.25;
          console.log(`Reaching check - LArm: ${leftArmReaching}, RArm: ${rightArmReaching}, LElbow: ${leftElbowReaching}, RElbow: ${rightElbowReaching}`);
        }
        console.log(`â FINAL BOW DETECTION: ${finalBowDetection}`);
        console.log('---');
      }
      
      return finalBowDetection;
    }

    // Setup MediaPipe Pose with error handling
    let pose;
    try {
      console.log('Initializing MediaPipe Pose...');
      pose = new Pose({locateFile: (file) => {
        const url = `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/${file}`;
        console.log('Loading MediaPipe file:', url);
        return url;
      }});
      pose.setOptions({
        modelComplexity: 1, 
        smoothLandmarks: true, 
        enableSegmentation: false,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });
      pose.onResults(onResults);
      console.log('MediaPipe Pose initialized successfully');
    } catch (error) {
      console.error('Failed to initialize MediaPipe Pose:', error);
      alert('Failed to load pose detection. Please refresh the page.');
    }

    async function detectPose() {
      const now = performance.now();
      
      // Frame rate limiting to prevent freezing
      if (now - lastFrameTime < FRAME_INTERVAL) {
        requestAnimationFrame(detectPose);
        return;
      }
      lastFrameTime = now;
      
      // Always run pose detection (not just during routine)
      detectionLoopRunning = true;
      lastDetectionTime = now;
      
      try {
        if (video.readyState >= 2 && video.videoWidth > 0 && video.videoHeight > 0) {
          // Additional check: ensure video is actually playing
          if (!video.paused && !video.ended) {
            await pose.send({image: video});
            poseFailureCount = 0;
          } else {
            console.log('Video not playing, skipping pose detection');
          }
        }
      } catch (error) {
        console.error('Pose detection error:', error);
        poseFailureCount++;
        
        // More aggressive recovery for persistent failures
        if (poseFailureCount >= MAX_POSE_FAILURES) {
          console.log('Too many pose detection failures, forcing recovery');
          // Clear canvas and reset everything
          if (showDebug && debugCtx) {
            debugCtx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
          }
          poseFailureCount = 0;
          consecutiveFailures = 0;
          lastSuccessfulPose = performance.now();
        }
      }
      
      requestAnimationFrame(detectPose);
    }

    function onResults(results) {
      const now = performance.now();
      
      if (!results.poseLandmarks) {
        consecutiveFailures++;
        console.log(`â POSE LOST - No landmarks (failure ${consecutiveFailures}/${RESTART_THRESHOLD}) - Routine state: ${routineState}`);
        
        // Alert if skeleton disappears during critical routine states
        if (routineState === ROUTINE_STATES.SETUP || routineState === ROUTINE_STATES.ACTIVE) {
          console.log(`ð¨ SKELETON DISAPPEARED during ${routineState.toUpperCase()} state!`);
        }
        
        // Check if frozen (no successful pose for too long)
        if (now - lastSuccessfulPose > MAX_FREEZE_TIME) {
          console.log('Pose detection appears frozen, attempting recovery...');
          poseStatus.textContent = 'Pose: Recovering from freeze...';
          poseStatus.style.color = '#ff5722';
          
          // Force canvas clear and reset
          if (showDebug) {
            debugCtx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
          }
          lastSuccessfulPose = now; // Reset timer
          consecutiveFailures = 0; // Reset failure counter
        } else {
          // Don't immediately change status - give pose detection more time
          if (consecutiveFailures < 5) {
            poseStatus.textContent = 'Pose: Searching...';
            poseStatus.style.color = '#ffc107';
          } else {
            poseStatus.textContent = 'Pose: Not detected - check lighting';
            poseStatus.style.color = '#888';
          }
        }
        
        return;
      } else {
        // Successful pose detection - reset counters
        consecutiveFailures = 0;
        lastSuccessfulPose = now;
        console.log('Pose landmarks detected! Count:', results.poseLandmarks.length);
      }

      const landmarks = results.poseLandmarks;
      

      // Map keypoints
      const leftHip = landmarks[23], rightHip = landmarks[24];
      const leftKnee = landmarks[25], rightKnee = landmarks[26];
      const leftAnkle = landmarks[27], rightAnkle = landmarks[28];

      // Check if all required landmarks are visible (confidence > 0.5)
      const requiredLandmarks = [leftHip, rightHip, leftKnee, rightKnee, leftAnkle, rightAnkle];
      if (requiredLandmarks.some(landmark => !landmark || landmark.visibility < 0.5)) {
        console.log('Some required landmarks not visible or low confidence');
        poseStatus.textContent = 'Pose: Low confidence';
        poseStatus.style.color = '#ff9800';
        return;
      }

      // Good pose detection
      poseStatus.textContent = 'Pose: Tracking â';
      poseStatus.style.color = '#4caf50';
      
      // Gesture detection for auto start/stop
      if (routineState === ROUTINE_STATES.SETUP && waitingForSalute) {
        const isSaluting = detectSalute(landmarks);
        if (isSaluting) {
          gestureHoldFrames++;
          poseStatus.textContent = `Salute detected... ${Math.round(100 * gestureHoldFrames / SALUTE_CONFIRM_FRAMES)}%`;
          poseStatus.style.color = '#4caf50';
          console.log(`ð SALUTE PROGRESS ${gestureHoldFrames}/${SALUTE_CONFIRM_FRAMES}`);
          if (gestureHoldFrames >= SALUTE_CONFIRM_FRAMES) {
            console.log('â SALUTE CONFIRMED - Starting routine!');
            startRoutineAutomatically();
          }
        } else {
          gestureHoldFrames = 0;
          poseStatus.textContent = 'Ready - Waiting for Salute (raise one arm)';
          poseStatus.style.color = '#ff9800';
        }
      } else if (routineState === ROUTINE_STATES.ACTIVE && waitingForBow) {
        const isBowing = detectBow(landmarks);
        if (isBowing) {
          console.log('Bow detected immediately - ending routine!');
          endRoutineAutomatically();
        } else {
          if (routineState === ROUTINE_STATES.ACTIVE) {
            poseStatus.textContent = 'Routine Active - Bow to finish';
            poseStatus.style.color = '#ff9800';
          }
        }
      }

      // Knee angles
      const leftKneeAngle = calculateAngle(leftHip, leftKnee, leftAnkle);
      const rightKneeAngle = calculateAngle(rightHip, rightKnee, rightAnkle);
      const kneeThreshold = 160; // More sensitive - was 170

      // Body width measurements
      const hipDistance = distance(leftHip, rightHip);
      const ankleDist = distance(leftAnkle, rightAnkle);
      const kneeDist = distance(leftKnee, rightKnee);

      // Debug measurements every 60 frames (~1 second at 60fps) - AFTER variables declared
      if (Math.random() < 0.016) {
        console.log(`Measurements - Knee angles L:${leftKneeAngle.toFixed(1)}Â° R:${rightKneeAngle.toFixed(1)}Â°`);
        console.log(`Distances - Hips:${hipDistance.toFixed(3)} Ankles:${ankleDist.toFixed(3)} Knees:${kneeDist.toFixed(3)}`);
        console.log(`Ratios - Ankle/Hip:${(ankleDist/hipDistance).toFixed(2)} Knee/Hip:${(kneeDist/hipDistance).toFixed(2)}`);
        console.log(`Cooldowns - Left leg: ${((performance.now() - (lastDeductionAt['Left leg bent'] || 0))/1000).toFixed(1)}s ago, Right leg: ${((performance.now() - (lastDeductionAt['Right leg bent'] || 0))/1000).toFixed(1)}s ago`);
      }
      
      // More sensitive legs apart detection - multiple methods
      const maxAnkleDistFactor = 1.3; // was 1.5 - more strict
      const maxKneeDistFactor = 1.4;  // knee distance shouldn't exceed this either
      
      // Also check absolute distance (for very wide stances)
      const maxAbsoluteAnkleDist = 0.3; // normalized coordinate distance

      // Check deductions with debugging - ONLY during ACTIVE routine state
      if (routineState === ROUTINE_STATES.ACTIVE) {
        const now = performance.now();
        const inMountingGrace = now < mountingGracePeriod;
        
        if (inMountingGrace && Math.random() < 0.02) { // Occasional logging during grace period
          console.log(`Mounting grace period active - ${((mountingGracePeriod - now)/1000).toFixed(1)}s remaining`);
        }
        
        if (leftKneeAngle < kneeThreshold) {
          if (!inMountingGrace) {
            console.log(`Left leg bent detected: ${leftKneeAngle.toFixed(1)}Â° < ${kneeThreshold}Â°`);
            addDeduction("Left leg bent");
          } else {
            console.log(`Left leg bent during mounting - allowed (${leftKneeAngle.toFixed(1)}Â°)`);
          }
        } else if (leftKneeAngle < kneeThreshold + 5) {
          // Log near-misses to see if angles are fluctuating around threshold
          console.log(`Left leg close to bent: ${leftKneeAngle.toFixed(1)}Â° (threshold: ${kneeThreshold}Â°)`);
        }
        
        if (rightKneeAngle < kneeThreshold) {
          if (!inMountingGrace) {
            console.log(`Right leg bent detected: ${rightKneeAngle.toFixed(1)}Â° < ${kneeThreshold}Â°`);
            addDeduction("Right leg bent");
          } else {
            console.log(`Right leg bent during mounting - allowed (${rightKneeAngle.toFixed(1)}Â°)`);
          }
        } else if (rightKneeAngle < kneeThreshold + 5) {
          console.log(`Right leg close to bent: ${rightKneeAngle.toFixed(1)}Â° (threshold: ${kneeThreshold}Â°)`);
        }
      }
      // Multiple checks for legs too far apart - ONLY during ACTIVE routine state
      if (routineState === ROUTINE_STATES.ACTIVE) {
        const now = performance.now();
        const inMountingGrace = now < mountingGracePeriod;
        const ankleRatio = ankleDist / hipDistance;
        const kneeRatio = kneeDist / hipDistance;
        
        if (ankleRatio > maxAnkleDistFactor) {
          if (!inMountingGrace) {
            console.log(`Legs apart (ankle ratio): ${ankleRatio.toFixed(2)} > ${maxAnkleDistFactor}`);
            addDeduction("Legs too far apart");
          } else {
            console.log(`Legs apart during mounting - allowed (ankle ratio: ${ankleRatio.toFixed(2)})`);
          }
        } else if (kneeRatio > maxKneeDistFactor) {
          if (!inMountingGrace) {
            console.log(`Legs apart (knee ratio): ${kneeRatio.toFixed(2)} > ${maxKneeDistFactor}`);
            addDeduction("Legs too far apart");
          } else {
            console.log(`Legs apart during mounting - allowed (knee ratio: ${kneeRatio.toFixed(2)})`);
          }
        } else if (ankleDist > maxAbsoluteAnkleDist) {
          if (!inMountingGrace) {
            console.log(`Legs apart (absolute): ${ankleDist.toFixed(3)} > ${maxAbsoluteAnkleDist}`);
            addDeduction("Legs too far apart");
          } else {
            console.log(`Legs apart during mounting - allowed (absolute: ${ankleDist.toFixed(3)})`);
          }
        }
      }
    }

    function addDeduction(reason) {
      // Allow repeated deductions for the same reason after a short cooldown
      const now = performance.now();
      const lastTime = lastDeductionAt[reason] || 0;
      if (now - lastTime < DEDUCTION_COOLDOWN_MS) {
        console.log(`Deduction "${reason}" blocked by cooldown (${((now - lastTime)/1000).toFixed(1)}s ago)`);
        return;
      }
      
      // Safety check: prevent excessive deduction frequency
      if (deductionTimestamps.length > 50) {
        console.warn('Deduction limit reached to prevent system overload');
        return;
      }
      
      lastDeductionAt[reason] = now;
      
      // Log current state before deduction
      console.log(`BEFORE deduction - Current score: ${score.toFixed(1)}, Routine state: ${routineState}`);

      // Apply deduction with proper minimum score of 5.0
      score = Math.max(5.0, score - 0.2);
      console.log(`Deduction applied: "${reason}" - New score: ${score.toFixed(1)}, min: 5.0`);
      
      // Double check we're not stopping too early
      if (score > 5.0 && score < 8.0) {
        console.log('Score in danger zone, verifying min score enforcement');
      }

      // Record timestamp for replay (time since routine started)
      const videoTime = (now - routineStartTime) / 1000; // Convert to seconds
      deductionTimestamps.push({
        time: videoTime,
        reason: reason,
        score: score.toFixed(1)
      });
      console.log(`Deduction timestamp recorded: ${videoTime.toFixed(2)}s into routine`);

      // Simply update the score display - no snapshots or logging needed
      scoreDisplay.textContent = score.toFixed(1);
      console.log(`Score updated to ${score.toFixed(1)} - deduction will be shown in video replay`);
    }
    
    function startRoutineAutomatically() {
      if (!mediaStream) return;
      
      // Transition to ACTIVE state - deductions now enabled
      routineState = ROUTINE_STATES.ACTIVE;
      routineStarted = true;
      waitingForSalute = false;
      waitingForBow = true;
      gestureHoldFrames = 0;
      
      console.log('Routine state: SETUP â ACTIVE (deductions enabled)');
      
      startBtn.disabled = true;
      
      // Reset score & tracking
      score = 10.0;
      lastDeductionAt = {};
      deductionTimestamps = []; // Reset deduction timestamps
      scoreDisplay.textContent = score.toFixed(1);
      
      // Record routine start time for video timing
      routineStartTime = performance.now();
      mountingGracePeriod = routineStartTime + 5000; // 5 second grace period for mounting
      console.log('Routine start time recorded for video timing');
      console.log('5-second mounting grace period active - legs apart allowed for pommel mount');
      
      // Setup MediaRecorder
      recordedChunks = []; // Clear previous recording
      mediaRecorder = new MediaRecorder(mediaStream, { mimeType: "video/webm" });
      mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
      mediaRecorder.onstop = () => {
        // Store video blob for replay instead of downloading
        recordedVideoBlob = new Blob(recordedChunks, { type: "video/webm" });
        console.log('Video recorded, starting replay system');
        startReplay();
      };
      mediaRecorder.start();
      
      poseStatus.textContent = 'Routine Started - Tracking Performance';
      poseStatus.style.color = '#ff9800';
    }
    
    function endRoutineAutomatically() {
      if (mediaRecorder && mediaRecorder.state === "recording") mediaRecorder.stop();
      
      // Transition to FINISHED state - deductions now disabled
      routineState = ROUTINE_STATES.FINISHED;
      routineStarted = false;
      waitingForBow = false;
      waitingForSalute = false;
      gestureHoldFrames = 0;
      
      console.log('Routine state: ACTIVE â FINISHED (deductions disabled)');
      
      // Return to WAITING state - ready for next routine
      routineState = ROUTINE_STATES.WAITING;
      startBtn.disabled = false;
      startBtn.textContent = 'Ready for Routine';
      
      console.log('Routine state: FINISHED â WAITING (ready for next routine)');
      
      poseStatus.textContent = 'Routine Complete - Ready for Next';
      poseStatus.style.color = '#4caf50';
      
      // Don't show alert immediately - replay will handle this
      console.log(`Routine complete! Final Score: ${score.toFixed(1)}`);
    }
    
    function startReplay() {
      // Show replay section
      replaySection.style.display = 'block';
      
      // Set up video source
      const videoUrl = URL.createObjectURL(recordedVideoBlob);
      replayVideo.src = videoUrl;
      
      console.log(`Starting replay with ${deductionTimestamps.length} deductions to pause at:`, deductionTimestamps);
      
      // Start countdown
      let countdown = 3;
      replayStatus.textContent = `Replay starting in ${countdown} seconds...`;
      
      const countdownInterval = setInterval(() => {
        countdown--;
        if (countdown > 0) {
          replayStatus.textContent = `Replay starting in ${countdown} seconds...`;
        } else {
          clearInterval(countdownInterval);
          replayStatus.textContent = 'Playing routine - will pause at deductions';
          startVideoPlayback();
        }
      }, 1000);
    }
    
    function startVideoPlayback() {
      let currentDeductionIndex = 0;
      let isPaused = false;
      
      replayVideo.play();
      
      // Monitor video progress and pause at deductions
      replayVideo.addEventListener('timeupdate', function checkForDeductions() {
        const currentTime = replayVideo.currentTime;
        
        // Check if we need to pause at a deduction
        if (!isPaused && currentDeductionIndex < deductionTimestamps.length) {
          const nextDeduction = deductionTimestamps[currentDeductionIndex];
          
          // Pause if we've reached or passed the deduction time
          if (currentTime >= nextDeduction.time) {
            isPaused = true;
            replayVideo.pause();
            
            replayStatus.textContent = `DEDUCTION: ${nextDeduction.reason} - Score: ${nextDeduction.score} (pausing 2 seconds)`;
            replayStatus.style.color = '#ff5722';
            
            console.log(`Paused at deduction ${currentDeductionIndex + 1}: ${nextDeduction.reason} at ${nextDeduction.time.toFixed(2)}s`);
            
            // Resume after 2 seconds
            setTimeout(() => {
              currentDeductionIndex++;
              isPaused = false;
              replayVideo.play();
              
              if (currentDeductionIndex < deductionTimestamps.length) {
                replayStatus.textContent = 'Playing routine - will pause at next deduction';
              } else {
                replayStatus.textContent = 'Playing routine - no more deductions';
              }
              replayStatus.style.color = '#ff9800';
            }, 2000);
          }
        }
      });
      
      // Handle video end
      replayVideo.addEventListener('ended', () => {
        replayStatus.textContent = `Routine Complete! Final Score: ${score.toFixed(1)}`;
        replayStatus.style.color = '#4caf50';
        console.log('Replay finished');
        
        // Clean up video URL
        URL.revokeObjectURL(replayVideo.src);
      });
    }

    // Start routine - now activates gesture detection mode
    startBtn.addEventListener('click', () => {
      if (!mediaStream) return alert("Camera not ready yet");

      // Transition to SETUP state - waiting for salute (no deductions yet)
      routineState = ROUTINE_STATES.SETUP;
      waitingForSalute = true;
      waitingForBow = false;
      gestureHoldFrames = 0;
      
      // Reset salute detection
      
      console.log('Routine state: WAITING â SETUP (waiting for salute, no deductions)');
      
      startBtn.textContent = 'Waiting for Salute...';
      startBtn.disabled = true;
      
      poseStatus.textContent = 'Ready - Waiting for Salute';
      poseStatus.style.color = '#ff9800';
      
      console.log('Gesture detection activated - raise one arm to salute and start routine');
      // Pose detection is already running continuously
    });

    // Manual end button removed - using automatic bow detection only

    // Clear log functionality removed - using video replay instead
    
    // Debug skeleton functionality removed
    
    // Close replay and reset for next routine
    closeReplayBtn.addEventListener('click', () => {
      // Hide replay section
      replaySection.style.display = 'none';
      
      // Stop video and clean up
      replayVideo.pause();
      if (replayVideo.src) {
        URL.revokeObjectURL(replayVideo.src);
      }
      replayVideo.src = '';
      
      // Reset for next routine
      routineState = ROUTINE_STATES.WAITING;
      startBtn.disabled = false;
      startBtn.textContent = 'Ready for Routine';
      
      // Reset score for next person
      score = 10.0;
      scoreDisplay.textContent = score.toFixed(1);
      lastDeductionAt = {}; // Clear deduction cooldowns
      
      // Clear recorded data
      recordedVideoBlob = null;
      deductionTimestamps = [];
      recordedChunks = [];
      mountingGracePeriod = 0;
      
      poseStatus.textContent = 'Ready for Next Routine - Score Reset';
      poseStatus.style.color = '#4caf50';
      
      console.log('Replay closed, ready for next routine');
    });
  </script>
</body>
</html>
