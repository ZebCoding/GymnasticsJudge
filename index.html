<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gymnastics Judge AI - Pommel Horse/Mushroom</title>
  
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; background: #000; color: white; overflow: hidden; }
    
    /* Fullscreen video container */
    .video-fullscreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1;
    }
    
    #camera, #replayVideo {
      width: 100%;
      height: 100%;
      object-fit: contain;
      border: none;
      background: #000;
    }
    
    /* Overlay UI elements */
    .ui-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
      background: linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, transparent 15%, transparent 85%, rgba(0,0,0,0.7) 100%);
    }
    
    /* Top bar with score and status */
    .top-bar {
      position: absolute;
      top: 20px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 20px;
      pointer-events: none;
    }
    
    .score {
      font-size: 4em;
      font-weight: bold;
      color: #00ff00;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      margin: 0;
    }
    
    .status-info {
      text-align: right;
      font-size: 1.2em;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    }
    
    #poseStatus {
      margin: 0;
      font-weight: bold;
    }
    
    /* Bottom controls */
    .bottom-controls {
      position: absolute;
      bottom: 30px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      pointer-events: all;
    }
    
    button {
      padding: 20px 30px;
      margin: 0 10px;
      font-size: 1.3em;
      font-weight: bold;
      border: none;
      border-radius: 12px;
      background: rgba(0, 123, 255, 0.9);
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    
    button:hover {
      background: rgba(0, 86, 179, 0.95);
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(0,0,0,0.5);
    }
    
    button:disabled {
      background: rgba(85, 85, 85, 0.7);
      cursor: not-allowed;
      transform: none;
    }
    
    /* Replay status overlay - positioned at top */
    .replay-status {
      position: absolute;
      top: 100px; /* Below the score and status bar */
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.9);
      padding: 15px 25px;
      border-radius: 8px;
      font-size: 1.3em;
      font-weight: bold;
      text-align: center;
      pointer-events: none;
      box-shadow: 0 4px 20px rgba(0,0,0,0.7);
      border: 2px solid rgba(255, 255, 255, 0.2);
    }
    
    /* Hide replay section initially */
    #replaySection {
      display: none;
      z-index: 5; /* Above camera feed but below UI overlay */
    }
    
    
    /* Mobile adjustments */
    @media (max-width: 768px) {
      .score {
        font-size: 3em;
      }
      
      .status-info {
        font-size: 1em;
      }
      
      button {
        padding: 18px 25px;
        font-size: 1.2em;
      }
      
      .top-bar {
        padding: 0 15px;
      }
      
      .replay-status {
        font-size: 1.2em;
        padding: 12px 20px;
        top: 90px; /* Closer to top bar on mobile */
      }
    }
    
    @media (max-width: 480px) {
      .score {
        font-size: 2.5em;
      }
      
      .status-info {
        font-size: 0.9em;
      }
      
      button {
        padding: 15px 20px;
        font-size: 1.1em;
        margin: 0 5px;
      }
      
      .replay-status {
        font-size: 1.0em;
        padding: 10px 15px;
        top: 80px; /* Even closer on small screens */
      }
    }
  </style>
  <!-- Load MediaPipe Pose -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</head>
<body>
  <!-- Main camera video (fullscreen) -->
  <div class="video-fullscreen">
    <video id="camera" autoplay playsinline></video>
  </div>
  
  <!-- Replay video (overlays camera when active) -->
  <div id="replaySection" class="video-fullscreen">
    <video id="replayVideo"></video>
  </div>
  
  <!-- UI Overlay -->
  <div class="ui-overlay">
    <!-- Top bar with score and status -->
    <div class="top-bar">
      <div class="score">Score: <span id="score">10.0</span></div>
      <div class="status-info">
        <div id="poseStatus">Pose: Not detecting</div>
        <div id="circleCount" style="font-size: 1.5em; font-weight: bold; margin-top: 5px;">Circles: 0.00</div>
      </div>
    </div>
    
    <!-- Bottom controls -->
    <div class="bottom-controls">
      <button id="startRoutine">Ready for Routine</button>
      <button id="closeReplay" style="display: none;">Close Replay & Ready for Next</button>
    </div>
    
    <!-- Replay status overlay (center screen) -->
    <div id="replayStatus" class="replay-status" style="display: none;">
      Replay starting in 3 seconds...
    </div>
    
  </div>

  <script>
    console.log('🚀 JavaScript starting to load...');
    const video = document.getElementById('camera');
    const scoreDisplay = document.getElementById('score');
    const poseStatus = document.getElementById('poseStatus');
    const circleCountDisplay = document.getElementById('circleCount');
    const replaySection = document.getElementById('replaySection');
    const replayVideo = document.getElementById('replayVideo');
    const replayStatus = document.getElementById('replayStatus');

    const startBtn = document.getElementById('startRoutine');
    const closeReplayBtn = document.getElementById('closeReplay');
    
    

    let score = 10.0;
    let mediaStream;
    let mediaRecorder;
    let recordedChunks = [];
    let routineStartTime = 0; // When routine actually started (for video timing)
    let recordedVideoBlob = null; // Store video for replay
    let deductionTimestamps = []; // Store when deductions occurred for replay pausing
    let routineStarted = false;
    let circleCount = 0; // Count of completed circles
    
    // Circle detection variables
    let lastAngle = null; // Track body angle relative to apparatus
    let totalRotation = 0; // Accumulated rotation in degrees
    let lastValidPositionTime = 0; // Track last time we had valid position data
    
    // Circle-based deduction system (realistic gymnastics judging)
    let currentCircleStartTime = 0; // When current circle started
    let currentCircleWorstBending = 0; // Worst bending violation in current circle (0.0-0.3)
    let currentCircleWorstSpreading = 0; // Worst spreading violation in current circle (0.0-0.3)
    let currentCircleDeductionApplied = false; // Has deduction been applied for current circle?
    let circleDeductions = []; // Track deductions per circle for replay
    
    // Step-off detection variables (for mushroom/pommel horse)
    let baselineCenterX = null; // Baseline horizontal center when on apparatus
    let stepOffGracePeriod = 0; // Time when step-off grace period ends
    let hasSteppedOff = false; // Track if gymnast has stepped off to side
    
    // Landing step detection variables
    let landingPosition = null; // Position when first landing is detected
    let lastStepCheckTime = 0; // Prevent too frequent step checks
    
    // Routine state machine
    const ROUTINE_STATES = {
      WAITING: 'waiting',     // Before "Ready for Routine" clicked
      SETUP: 'setup',         // After button click, waiting for salute
      ACTIVE: 'active',       // After salute, routine in progress (deductions active)
      FINISHED: 'finished'    // After bow, routine complete (no more deductions)
    };
    let routineState = ROUTINE_STATES.WAITING;
    
    // Ground contact detection for intelligent deduction logic
    let hasEverBeenAirborne = false; // Has gymnast ever had both feet off ground?
    let currentlyGrounded = true;    // Are both feet currently on ground?
    let lastGroundCheckTime = 0;     // Prevent too frequent ground checks

    // Removed old cooldown system - using realistic circle-based judging instead
    
    // Detection loop monitoring
    let lastDetectionTime = 0;
    let detectionLoopRunning = false;
    let poseFailureCount = 0;
    const MAX_POSE_FAILURES = 10;
    
    // Frame rate limiting to prevent freezing
    let lastFrameTime = 0;
    const TARGET_FPS = 15; // Limit to 15fps for better stability
    const FRAME_INTERVAL = 1000 / TARGET_FPS;
    
    // Anti-freeze monitoring
    let consecutiveFailures = 0;
    let lastSuccessfulPose = 0;
    const MAX_FREEZE_TIME = 3000; // 3 seconds without pose updates = frozen
    const RESTART_THRESHOLD = 5; // Restart after 5 consecutive failures
    
    
    // Gesture detection
    let waitingForSalute = false;
    let waitingForBow = false;
    let gestureHoldFrames = 0; // Still used for salute
    const SALUTE_ARM_ANGLE_THRESHOLD = 45; // arms up angle
    
    // Salute detection - simplified to immediate trigger
    const SALUTE_CONFIRM_FRAMES = 5; // ~0.08 seconds to confirm salute

    // Get camera and start pose detection immediately with fallback options
    console.log('🎥 Requesting camera access...');
    
    async function initializeCamera() {
      const constraints = [
        // Try high quality first
        { 
          video: { 
            width: { ideal: 1280 },
            height: { ideal: 720 },
            facingMode: 'user'
          } 
        },
        // Fallback to basic video
        { video: { facingMode: 'user' } },
        // Final fallback - any video
        { video: true }
      ];
      
      for (let i = 0; i < constraints.length; i++) {
        try {
          console.log(`🔍 Trying camera option ${i + 1}/${constraints.length}...`);
          const stream = await navigator.mediaDevices.getUserMedia(constraints[i]);
          
          console.log('✅ Camera stream obtained');
          mediaStream = stream; 
          video.srcObject = stream;
          
          // Force video to play
          try {
            await video.play();
            console.log('📹 Video playing successfully');
          } catch (playErr) {
            console.error('❌ Video play error:', playErr);
          }
          
          // Multiple ways to start pose detection
          video.addEventListener('loadeddata', () => {
            console.log('📊 Video loaded, dimensions:', video.videoWidth, 'x', video.videoHeight);
            setTimeout(() => {
              console.log('🤖 Starting pose detection from loadeddata...');
              detectPose();
            }, 1000);
          });
          
          // Backup timer to start pose detection
          setTimeout(() => {
            console.log('⏰ Backup timer: Force starting pose detection...');
            if (video.videoWidth > 0 && video.videoHeight > 0) {
              console.log('📊 Video dimensions from backup:', video.videoWidth, 'x', video.videoHeight);
              detectPose();
            } else {
              console.log('⚠️ Video not ready yet, trying again in 2s...');
              setTimeout(() => {
                console.log('⏰ Final attempt to start pose detection...');
                detectPose();
              }, 2000);
            }
          }, 3000);
          
          // Additional event listeners for debugging
          video.addEventListener('loadedmetadata', () => {
            console.log('📝 Video metadata loaded');
          });
          
          video.addEventListener('canplay', () => {
            console.log('▶️ Video can start playing');
          });
          
          video.addEventListener('playing', () => {
            console.log('🎥 Video is actively playing - pose detection should start soon');
          });
          
          return; // Success - exit the loop
          
        } catch (err) {
          console.warn(`⚠️ Camera option ${i + 1} failed:`, err.message);
          if (i === constraints.length - 1) {
            // All options failed
            console.error('❌ All camera options failed:', err);
            alert(`Camera not available: ${err.message}\n\nTry:\n1. Closing other apps using camera\n2. Refreshing the page\n3. Checking browser permissions`); 
          }
        }
      }
    }
    
    initializeCamera();

    // Utility functions
    function calculateAngle(A, B, C) {
      const AB = {x: B.x - A.x, y: B.y - A.y};
      const CB = {x: B.x - C.x, y: B.y - C.y};
      const dot = AB.x * CB.x + AB.y * CB.y;
      const magAB = Math.sqrt(AB.x*AB.x + AB.y*AB.y);
      const magCB = Math.sqrt(CB.x*CB.x + CB.y*CB.y);
      
      // Prevent division by zero or invalid angles
      if (magAB === 0 || magCB === 0) {
        console.log('Warning: Zero magnitude in angle calculation');
        return 180; // Return straight line angle as default
      }
      
      const cosAngle = dot / (magAB * magCB);
      // Clamp to valid range for acos to prevent NaN
      const clampedCos = Math.max(-1, Math.min(1, cosAngle));
      const angle = Math.acos(clampedCos) * (180/Math.PI);
      
      // Validate result
      if (isNaN(angle)) {
        console.log('Warning: NaN angle calculated, returning 180°');
        return 180;
      }
      
      return angle;
    }

    function distance(A, B) {
      return Math.sqrt((A.x - B.x)**2 + (A.y - B.y)**2);
    }
    
    function detectSalute(landmarks) {
      // One-arm salute detection with visibility + multiple cues
      const nose = landmarks[0];
      const leftShoulder = landmarks[11], rightShoulder = landmarks[12];
      const leftElbow = landmarks[13], rightElbow = landmarks[14];
      const leftWrist = landmarks[15], rightWrist = landmarks[16];
      
      if (!nose || !leftShoulder || !rightShoulder || !leftElbow || !rightElbow || !leftWrist || !rightWrist) return false;
      
      // Helper to validate landmark confidence
      const visOK = (lm) => lm.visibility === undefined || lm.visibility >= 0.5;
      if (![nose, leftShoulder, rightShoulder, leftElbow, rightElbow, leftWrist, rightWrist].every(visOK)) {
        return false;
      }
      
      // Consider an arm raised if wrist and elbow are above shoulder (y smaller = higher)
      // and optionally wrist near head level to be robust to different body sizes
      const leftRaised = (leftWrist.y < leftShoulder.y - 0.08 && leftElbow.y < leftShoulder.y - 0.04) || (leftWrist.y < (nose.y + 0.05));
      const rightRaised = (rightWrist.y < rightShoulder.y - 0.08 && rightElbow.y < rightShoulder.y - 0.04) || (rightWrist.y < (nose.y + 0.05));
      
      // Accept salute when at least one arm is raised
      return leftRaised || rightRaised;
    }
    
    function detectArmsDown(landmarks) {
      // Check if both arms are down (at sides)
      const leftShoulder = landmarks[11], rightShoulder = landmarks[12];
      const leftElbow = landmarks[13], rightElbow = landmarks[14];
      const leftWrist = landmarks[15], rightWrist = landmarks[16];
      
      if (!leftShoulder || !rightShoulder || !leftElbow || !rightElbow || !leftWrist || !rightWrist) return false;
      
      // Helper to validate landmark confidence
      const visOK = (lm) => lm.visibility === undefined || lm.visibility >= 0.5;
      if (![leftShoulder, rightShoulder, leftElbow, rightElbow, leftWrist, rightWrist].every(visOK)) {
        return false;
      }
      
      // Arms are down if both wrists are at or below shoulder level
      const leftArmDown = leftWrist.y >= leftShoulder.y - 0.05;
      const rightArmDown = rightWrist.y >= rightShoulder.y - 0.05;
      
      return leftArmDown && rightArmDown;
    }
    
    function detectBow(landmarks) {
      // Bow detection based on real bowing posture analysis
      const nose = landmarks[0];
      const leftShoulder = landmarks[11], rightShoulder = landmarks[12];
      const leftHip = landmarks[23], rightHip = landmarks[24];
      const leftElbow = landmarks[13], rightElbow = landmarks[14];
      const leftWrist = landmarks[15], rightWrist = landmarks[16];
      
      if (!nose || !leftShoulder || !rightShoulder || !leftHip || !rightHip) return false;
      
      // Helper to validate landmark confidence
      const visOK = (lm) => lm.visibility === undefined || lm.visibility >= 0.4;
      if (![nose, leftShoulder, rightShoulder, leftHip, rightHip].every(visOK)) {
        return false;
      }
      
      // Calculate positions
      const shoulderY = (leftShoulder.y + rightShoulder.y) / 2;
      const hipY = (leftHip.y + rightHip.y) / 2;
      
      // Simple bow detection: significant head drop + arms not reaching equipment
      const headDrop = nose.y - shoulderY;
      const bowingDown = headDrop > 0.04; // Head dropped below shoulders = bow
      
      // Only check: are arms reaching for equipment? If not, allow the bow
      let armsAtSides = true;
      if (leftWrist && rightWrist && leftElbow && rightElbow) {
        // Block only if clearly reaching down for equipment (very generous thresholds)
        const leftArmReaching = leftWrist.y > leftShoulder.y + 0.3; // Very generous
        const rightArmReaching = rightWrist.y > rightShoulder.y + 0.3;
        const leftElbowReaching = leftElbow.y > leftShoulder.y + 0.25;
        const rightElbowReaching = rightElbow.y > rightShoulder.y + 0.25;
        
        // Only block if BOTH arms AND elbows are reaching down significantly
        const obviousReaching = (leftArmReaching && leftElbowReaching) || (rightArmReaching && rightElbowReaching);
        armsAtSides = !obviousReaching;
      }
      
      // Bow detection: head down + not obviously reaching for equipment
      const bowDetected = bowingDown && armsAtSides;
      
      const finalBowDetection = bowDetected;
      
      // Debug bow detection - show every time when routine is active and waiting for bow
      if (routineState === ROUTINE_STATES.ACTIVE && waitingForBow) {
        console.log(`🏹 BOW CHECK - Nose:${nose.y.toFixed(3)} Shoulder:${shoulderY.toFixed(3)}`);
        console.log(`Head drop: ${headDrop.toFixed(3)} (bowing down: ${headDrop.toFixed(3)} > 0.04 = ${bowingDown})`);
        console.log(`Arms at sides (not reaching equipment): ${armsAtSides}`);
        if (leftWrist && rightWrist && leftElbow && rightElbow) {
          console.log(`Arm positions - LWrist:${leftWrist.y.toFixed(3)} RWrist:${rightWrist.y.toFixed(3)} LElbow:${leftElbow.y.toFixed(3)} RElbow:${rightElbow.y.toFixed(3)}`);
          const leftArmReaching = leftWrist.y > leftShoulder.y + 0.3;
          const rightArmReaching = rightWrist.y > rightShoulder.y + 0.3;
          const leftElbowReaching = leftElbow.y > leftShoulder.y + 0.25;
          const rightElbowReaching = rightElbow.y > rightShoulder.y + 0.25;
          console.log(`Reaching check - LArm: ${leftArmReaching}, RArm: ${rightArmReaching}, LElbow: ${leftElbowReaching}, RElbow: ${rightElbowReaching}`);
        }
        console.log(`✅ FINAL BOW DETECTION: ${finalBowDetection}`);
        console.log('---');
      }
      
      return finalBowDetection;
    }
    
    function detectGroundContact(landmarks) {
      // Detect if gymnast's feet are on the ground or airborne
      const leftAnkle = landmarks[27], rightAnkle = landmarks[28];
      const leftHip = landmarks[23], rightHip = landmarks[24];
      const leftKnee = landmarks[25], rightKnee = landmarks[26];
      
      if (!leftAnkle || !rightAnkle || !leftHip || !rightHip) {
        return { grounded: true, confidence: 'low', mounting: true }; // Assume grounded/mounting if can't see feet
      }
      
      // Check visibility of both feet
      const leftVis = leftAnkle.visibility || 1;
      const rightVis = rightAnkle.visibility || 1;
      const avgVisibility = (leftVis + rightVis) / 2;
      const confidence = avgVisibility > 0.7 ? 'high' : 'low';
      
      // Calculate leg positions
      const leftLegLength = leftAnkle.y - leftHip.y;
      const rightLegLength = rightAnkle.y - rightHip.y;
      const avgLegLength = (leftLegLength + rightLegLength) / 2;
      
      // Calculate how close legs are together (ankle distance)
      const ankleDistance = Math.abs(leftAnkle.x - rightAnkle.x);
      
      // MOUNTING vs ROUTINE DETECTION:
      // Mounting = legs apart is OK, no deductions yet
      // Routine = legs should be together, deductions apply
      
      const actuallyAirborne = avgLegLength < 0.10; // Standard airborne threshold
      
      // Key insight: During mounting, legs are often apart (0.15+ distance)
      // During routine, legs should be close together (< 0.08 distance)
      const legsApart = ankleDistance > 0.08; // Legs spread apart
      const legsCloseish = ankleDistance < 0.08; // Legs close together
      
      let isGrounded, mounting;
      
      if (!actuallyAirborne) {
        // On ground = always mounting phase (legs apart allowed)
        isGrounded = true;
        mounting = true;
        if (Math.random() < 0.05) {
          console.log(`🦶 MOUNTING/GROUNDED: Ankle dist:${ankleDistance.toFixed(3)}, leg length:${avgLegLength.toFixed(3)} -> MOUNTING PHASE`);
        }
      } else if (actuallyAirborne && legsCloseish) {
        // Airborne + legs close together = routine started
        isGrounded = false;
        mounting = false;
        if (Math.random() < 0.05) {
          console.log(`🎢 ROUTINE: Airborne (${avgLegLength.toFixed(3)}) + legs close (${ankleDistance.toFixed(3)}) -> ROUTINE PHASE`);
        }
      } else {
        // Airborne but legs apart = still mounting/transitioning
        isGrounded = false;
        mounting = true;
        if (Math.random() < 0.05) {
          console.log(`⏳ TRANSITIONING: Airborne (${avgLegLength.toFixed(3)}) but legs apart (${ankleDistance.toFixed(3)}) -> STILL MOUNTING`);
        }
      }
      
      return { grounded: isGrounded, confidence: confidence, mounting: mounting };
    }
    
    function shouldApplyDeductions(landmarks) {
      // Determine deduction rules based on ground contact and visibility
      // 4 SCENARIOS FOR LEG CHECKING:
      // 1. Legs off ground AND visible → Check bending (penalize), Check spreading (penalize) 
      // 2. Legs behind pommel (not visible) → No checks (assume proper form)
      // 3. Beginning (mounting) → Check bending (allow), Check spreading (allow)
      // 4. Landed after routine → Check bending (allow), Check spreading (penalize)
      
      const now = performance.now();
      
      // Only check ground contact every 100ms to avoid excessive processing
      if (now - lastGroundCheckTime > 100) {
        const groundStatus = detectGroundContact(landmarks);
        currentlyGrounded = groundStatus.grounded;
        lastGroundCheckTime = now;
        
        // Track if gymnast has ever been airborne (both feet off ground)
        // Only trigger when both feet are visible and close together (not during mounting)
        if (!currentlyGrounded && !hasEverBeenAirborne && !groundStatus.mounting) {
          hasEverBeenAirborne = true;
          const legLength = ((landmarks[27].y + landmarks[28].y) / 2) - ((landmarks[23].y + landmarks[24].y) / 2);
          console.log(`🚁 GYMNAST NOW AIRBORNE! Both feet visible and close together - deduction rules now apply`);
        }
        
        // Debug ground contact and mounting detection
        if (Math.random() < 0.05) {
          const leftLegLength = landmarks[27].y - landmarks[23].y;
          const rightLegLength = landmarks[28].y - landmarks[24].y;
          const avgLegLength = (leftLegLength + rightLegLength) / 2;
          const leftVis = landmarks[27].visibility || 1;
          const rightVis = landmarks[28].visibility || 1;
          const ankleDistance = Math.abs(landmarks[27].x - landmarks[28].x);
          console.log(`👣 Ground: ${currentlyGrounded ? 'ON GROUND' : 'AIRBORNE'}, L:${leftLegLength.toFixed(3)} R:${rightLegLength.toFixed(3)} avg:${avgLegLength.toFixed(3)}, Mounting:${groundStatus.mounting}, Ankle dist:${ankleDistance.toFixed(3)}, L vis:${leftVis.toFixed(2)} R vis:${rightVis.toFixed(2)}, Ever airborne: ${hasEverBeenAirborne}`);
        }
      }
      
      // Check if legs are clearly visible for reliable deduction detection
      const leftAnkle = landmarks[27], rightAnkle = landmarks[28];
      const leftKnee = landmarks[25], rightKnee = landmarks[26];
      const leftHip = landmarks[23], rightHip = landmarks[24];
      
      const legLandmarks = [leftHip, rightHip, leftKnee, rightKnee, leftAnkle, rightAnkle];
      const visibleLegCount = legLandmarks.filter(lm => lm && (lm.visibility || 1) > 0.6).length;
      const legsVisible = visibleLegCount >= 4; // Need at least 4 of 6 leg landmarks visible
      
      if (!legsVisible) {
        // When legs aren't clearly visible (behind pommel horse), assume proper form
        if (Math.random() < 0.01) {
          console.log('🙈 Legs not clearly visible - assuming proper form (no deductions)');
        }
        return {
          checkBending: false,
          checkSpreading: false,
          reason: 'legs not visible - assumed proper'
        };
      }
      
      // Apply deduction rules based on ground contact and routine progress
      if (!hasEverBeenAirborne) {
        // Beginning phase - mounting (feet on ground): bending OK, straddling OK
        return {
          checkBending: false,
          checkSpreading: false,
          reason: 'mounting phase - feet on ground, bending/straddling allowed'
        };
      } else if (!currentlyGrounded) {
        // Airborne during routine: NO bending, NO straddling allowed  
        return {
          checkBending: true,
          checkSpreading: true,
          reason: 'airborne - no bending/straddling allowed'
        };
      } else {
        // Landed after routine: bending OK, NO straddling
        return {
          checkBending: false,
          checkSpreading: true,
          reason: 'landed after routine - bending OK, no straddling'
        };
      }
    }
    
    function evaluateBendingSeverity(leftKneeAngle, rightKneeAngle, kneeThreshold = 160) {
      // Evaluate how badly legs are bent (0.0 = perfect, 0.3 = worst)
      const leftBend = Math.max(0, kneeThreshold - leftKneeAngle);
      const rightBend = Math.max(0, kneeThreshold - rightKneeAngle);
      const worstBend = Math.max(leftBend, rightBend);
      
      if (worstBend <= 5) return 0.0;  // No significant bending
      if (worstBend <= 15) return 0.1; // Small bending (155-160°)
      if (worstBend <= 30) return 0.2; // Medium bending (130-155°)
      return 0.3;                       // Major bending (< 130°)
    }
    
    function evaluateSpreadingSeverity(landmarks, hipDistance, ankleDist, kneeDist) {
      // Evaluate how badly legs are spread (0.0 = perfect, 0.3 = worst)
      const ankleRatio = ankleDist / hipDistance;
      const kneeRatio = kneeDist / hipDistance;
      
      // Calculate worst spreading metric
      const ankleSpread = Math.max(0, ankleRatio - 1.0); // Normal = 1.0
      const kneeSpread = Math.max(0, kneeRatio - 1.0);   // Normal = 1.0
      const worstSpread = Math.max(ankleSpread, kneeSpread);
      
      if (worstSpread <= 0.2) return 0.0; // No significant spreading
      if (worstSpread <= 0.4) return 0.1; // Small spreading
      if (worstSpread <= 0.6) return 0.2; // Medium spreading  
      return 0.3;                          // Major spreading
    }
    
    function evaluateStepSeverity(movementDistance) {
      // Evaluate step severity for landing deductions (0.1, 0.2, or 0.3)
      const movePercent = movementDistance * 100; // Convert to percentage
      
      if (movePercent <= 3) return 0.0;  // Tiny adjustment, no deduction
      if (movePercent <= 8) return 0.1;  // Small step
      if (movePercent <= 15) return 0.2; // Medium step
      return 0.3;                         // Large step
    }
    
    function detectLegsApart(landmarks, hipDistance, ankleDist, kneeDist) {
      // Simple legs apart detection when rules require it
      const ankleRatio = ankleDist / hipDistance;
      const kneeRatio = kneeDist / hipDistance;
      const maxAnkleDistFactor = 1.4; // Allow slightly more tolerance
      const maxKneeDistFactor = 1.5;
      const maxAbsoluteAnkleDist = 0.25; // normalized coordinate distance
      
      const isApart = (ankleRatio > maxAnkleDistFactor) || 
                      (kneeRatio > maxKneeDistFactor) || 
                      (ankleDist > maxAbsoluteAnkleDist);
      
      return isApart;
    }

    // Setup MediaPipe Pose with error handling
    let pose;
    try {
      console.log('Initializing MediaPipe Pose...');
      pose = new Pose({locateFile: (file) => {
        const url = `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/${file}`;
        console.log('Loading MediaPipe file:', url);
        return url;
      }});
      pose.setOptions({
        modelComplexity: 1, 
        smoothLandmarks: true, 
        enableSegmentation: false,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });
      pose.onResults(onResults);
      console.log('MediaPipe Pose initialized successfully');
    } catch (error) {
      console.error('Failed to initialize MediaPipe Pose:', error);
      alert('Failed to load pose detection. Please refresh the page.');
    }

    async function detectPose() {
      const now = performance.now();
      
      // Log that pose detection is running every 5 seconds
      if (Math.random() < 0.001) {
        console.log('🔄 Pose detection loop is running...', {
          videoReady: video.readyState >= 2,
          videoPlaying: !video.paused && !video.ended,
          videoDimensions: `${video.videoWidth}x${video.videoHeight}`
        });
      }
      
      // Frame rate limiting to prevent freezing
      if (now - lastFrameTime < FRAME_INTERVAL) {
        requestAnimationFrame(detectPose);
        return;
      }
      lastFrameTime = now;
      
      // Always run pose detection (not just during routine)
      detectionLoopRunning = true;
      lastDetectionTime = now;
      
      try {
        if (video.readyState >= 2 && video.videoWidth > 0 && video.videoHeight > 0) {
          // Additional check: ensure video is actually playing
          if (!video.paused && !video.ended) {
            await pose.send({image: video});
            poseFailureCount = 0;
          } else {
            console.log('Video not playing, skipping pose detection');
          }
        }
      } catch (error) {
        console.error('Pose detection error:', error);
        poseFailureCount++;
        
        // More aggressive recovery for persistent failures
        if (poseFailureCount >= MAX_POSE_FAILURES) {
          console.log('Too many pose detection failures, forcing recovery');
          poseFailureCount = 0;
          consecutiveFailures = 0;
          lastSuccessfulPose = performance.now();
        }
      }
      
      requestAnimationFrame(detectPose);
    }

    function onResults(results) {
      const now = performance.now();
      
      if (!results.poseLandmarks) {
        consecutiveFailures++;
        console.log(`❌ POSE LOST - No landmarks (failure ${consecutiveFailures}/${RESTART_THRESHOLD}) - Routine state: ${routineState}`);
        
        // Alert if skeleton disappears during critical routine states
        if (routineState === ROUTINE_STATES.SETUP || routineState === ROUTINE_STATES.ACTIVE) {
          console.log(`🚨 SKELETON DISAPPEARED during ${routineState.toUpperCase()} state!`);
        }
        
        // Check if frozen (no successful pose for too long)
        if (now - lastSuccessfulPose > MAX_FREEZE_TIME) {
          console.log('Pose detection appears frozen, attempting recovery...');
          poseStatus.textContent = 'Pose: Recovering from freeze...';
          poseStatus.style.color = '#ff5722';
          
          lastSuccessfulPose = now; // Reset timer
          consecutiveFailures = 0; // Reset failure counter
        } else {
          // Don't immediately change status - give pose detection more time
          if (consecutiveFailures < 5) {
            poseStatus.textContent = 'Pose: Searching...';
            poseStatus.style.color = '#ffc107';
          } else {
            poseStatus.textContent = 'Pose: Not detected - check lighting';
            poseStatus.style.color = '#888';
          }
        }
        
        return;
      } else {
        // Successful pose detection - reset counters
        consecutiveFailures = 0;
        lastSuccessfulPose = now;
        console.log('Pose landmarks detected! Count:', results.poseLandmarks.length);
      }

      const landmarks = results.poseLandmarks;
      

      // Map keypoints
      const leftHip = landmarks[23], rightHip = landmarks[24];
      const leftKnee = landmarks[25], rightKnee = landmarks[26];
      const leftAnkle = landmarks[27], rightAnkle = landmarks[28];

      // Check if all required landmarks are visible (confidence > 0.5)
      const requiredLandmarks = [leftHip, rightHip, leftKnee, rightKnee, leftAnkle, rightAnkle];
      if (requiredLandmarks.some(landmark => !landmark || landmark.visibility < 0.5)) {
        console.log('Some required landmarks not visible or low confidence');
        poseStatus.textContent = 'Pose: Low confidence';
        poseStatus.style.color = '#ff9800';
        return;
      }

      // Good pose detection
      poseStatus.textContent = `Pose: Tracking ✓ (${landmarks.length} points)`;
      poseStatus.style.color = '#4caf50';
      
      // Debug pose detection more frequently when not in routine
      if (Math.random() < 0.02 || routineState === ROUTINE_STATES.SETUP) {
        console.log(`📍 POSE DEBUG - ${landmarks.length} landmarks detected, routine state: ${routineState}, waiting for salute: ${waitingForSalute}`);
      }
      
      // Gesture detection for auto start/stop
      if (routineState === ROUTINE_STATES.SETUP && waitingForSalute) {
        const isSaluting = detectSalute(landmarks);
        
        // Debug salute detection every 30 frames
        if (Math.random() < 0.033) {
          console.log('🔍 SALUTE DEBUG - Checking landmarks...');
          const nose = landmarks[0];
          const leftShoulder = landmarks[11], rightShoulder = landmarks[12];
          const leftWrist = landmarks[15], rightWrist = landmarks[16];
          if (leftWrist && rightWrist && leftShoulder && rightShoulder) {
            console.log(`Left wrist Y: ${leftWrist.y.toFixed(3)}, Left shoulder Y: ${leftShoulder.y.toFixed(3)}, Raised: ${leftWrist.y < leftShoulder.y - 0.08}`);
            console.log(`Right wrist Y: ${rightWrist.y.toFixed(3)}, Right shoulder Y: ${rightShoulder.y.toFixed(3)}, Raised: ${rightWrist.y < rightShoulder.y - 0.08}`);
            console.log(`Salute detected: ${isSaluting}`);
          } else {
            console.log('Missing key landmarks for salute detection');
          }
        }
        
        if (isSaluting) {
          gestureHoldFrames++;
          poseStatus.textContent = `Salute detected... ${Math.round(100 * gestureHoldFrames / SALUTE_CONFIRM_FRAMES)}%`;
          poseStatus.style.color = '#4caf50';
          console.log(`👋 SALUTE PROGRESS ${gestureHoldFrames}/${SALUTE_CONFIRM_FRAMES}`);
          if (gestureHoldFrames >= SALUTE_CONFIRM_FRAMES) {
            console.log('✅ SALUTE CONFIRMED - Starting routine!');
            startRoutineAutomatically();
          }
        } else {
          gestureHoldFrames = 0;
          poseStatus.textContent = 'Ready - Waiting for Salute (raise one arm)';
          poseStatus.style.color = '#ff9800';
        }
      } else if (routineState === ROUTINE_STATES.ACTIVE && waitingForBow) {
        const isBowing = detectBow(landmarks);
        if (isBowing) {
          console.log('Bow detected immediately - ending routine!');
          endRoutineAutomatically();
        } else {
          if (routineState === ROUTINE_STATES.ACTIVE) {
            poseStatus.textContent = 'Routine Active - Bow to finish';
            poseStatus.style.color = '#ff9800';
          }
        }
      }

      // Knee angles
      const leftKneeAngle = calculateAngle(leftHip, leftKnee, leftAnkle);
      const rightKneeAngle = calculateAngle(rightHip, rightKnee, rightAnkle);
      const kneeThreshold = 100; // Extremely less sensitive - only severe bending (90° bend)

      // Body width measurements
      const hipDistance = distance(leftHip, rightHip);
      const ankleDist = distance(leftAnkle, rightAnkle);
      const kneeDist = distance(leftKnee, rightKnee);

      // Debug measurements every 60 frames (~1 second at 60fps) - AFTER variables declared
      if (Math.random() < 0.016) {
        console.log(`Measurements - Knee angles L:${leftKneeAngle.toFixed(1)}° R:${rightKneeAngle.toFixed(1)}°`);
        console.log(`Distances - Hips:${hipDistance.toFixed(3)} Ankles:${ankleDist.toFixed(3)} Knees:${kneeDist.toFixed(3)}`);
        console.log(`Ratios - Ankle/Hip:${(ankleDist/hipDistance).toFixed(2)} Knee/Hip:${(kneeDist/hipDistance).toFixed(2)}`);
        
        // Additional knee angle debugging
        const leftBending = Math.max(0, kneeThreshold - leftKneeAngle);
        const rightBending = Math.max(0, kneeThreshold - rightKneeAngle);
        if (leftBending > 5 || rightBending > 5) {
          console.log(`⚠️ POTENTIAL BENDING DETECTED - L bend:${leftBending.toFixed(1)}° R bend:${rightBending.toFixed(1)}° (threshold:${kneeThreshold}°)`);
          console.log(`   Landmarks - LHip:(${leftHip.x.toFixed(3)},${leftHip.y.toFixed(3)}) LKnee:(${leftKnee.x.toFixed(3)},${leftKnee.y.toFixed(3)}) LAnkle:(${leftAnkle.x.toFixed(3)},${leftAnkle.y.toFixed(3)})`);
          console.log(`   Landmarks - RHip:(${rightHip.x.toFixed(3)},${rightHip.y.toFixed(3)}) RKnee:(${rightKnee.x.toFixed(3)},${rightKnee.y.toFixed(3)}) RAnkle:(${rightAnkle.x.toFixed(3)},${rightAnkle.y.toFixed(3)})`);
        }
      }
      
      // More sensitive legs apart detection - multiple methods
      const maxAnkleDistFactor = 1.3; // was 1.5 - more strict
      const maxKneeDistFactor = 1.4;  // knee distance shouldn't exceed this either
      
      // Also check absolute distance (for very wide stances)
      const maxAbsoluteAnkleDist = 0.3; // normalized coordinate distance

      // Ground contact-based deduction logic - ONLY during ACTIVE routine state
      if (routineState === ROUTINE_STATES.ACTIVE) {
        const deductionRules = shouldApplyDeductions(landmarks);
        
        // Debug the current deduction rules occasionally
        if (Math.random() < 0.01) {
          console.log(`🎯 Deduction rules: ${deductionRules.reason}`);
          console.log(`  Check bending: ${deductionRules.checkBending}, Check spreading: ${deductionRules.checkSpreading}`);
        }
        
        // Realistic circle-based deduction system
        if (deductionRules.checkBending || deductionRules.checkSpreading) {
          // Evaluate current form quality
          // Additional check: if legs are very close together, likely not bent (prevent false positives)
          const ankleDistance = Math.abs(landmarks[27].x - landmarks[28].x);
          const legsVeryCloseTogether = ankleDistance < 0.08; // More forgiving - if legs reasonably close, skip bending check
          
          let bendingSeverity = 0;
          if (deductionRules.checkBending && !legsVeryCloseTogether) {
            bendingSeverity = evaluateBendingSeverity(leftKneeAngle, rightKneeAngle);
          } else if (legsVeryCloseTogether && Math.random() < 0.01) {
            console.log(`✅ Skipping bending check - legs very close together (${ankleDistance.toFixed(3)})`);
          }
          
          const spreadingSeverity = deductionRules.checkSpreading ? evaluateSpreadingSeverity(landmarks, hipDistance, ankleDist, kneeDist) : 0;
          
          // Track worst mistakes in current circle
          if (bendingSeverity > currentCircleWorstBending) {
            currentCircleWorstBending = bendingSeverity;
            if (bendingSeverity > 0) {
              console.log(`🚨 BENDING SEVERITY RECORDED: ${bendingSeverity.toFixed(1)} - L:${leftKneeAngle.toFixed(1)}° R:${rightKneeAngle.toFixed(1)}° (threshold:${kneeThreshold}°)`);
              recordMistakeForReplay("bending", bendingSeverity);
            }
          }
          
          if (spreadingSeverity > currentCircleWorstSpreading) {
            currentCircleWorstSpreading = spreadingSeverity;
            if (spreadingSeverity > 0) {
              recordMistakeForReplay("spreading", spreadingSeverity);
            }
          }
          
          // Debug current form quality occasionally
          if (Math.random() < 0.005) {
            console.log(`🔍 Form check - Bending: ${bendingSeverity.toFixed(1)}, Spreading: ${spreadingSeverity.toFixed(1)}, Circle worst: B${currentCircleWorstBending.toFixed(1)}/S${currentCircleWorstSpreading.toFixed(1)}`);
          }
        } else {
          // Log when deductions are not being applied
          if (Math.random() < 0.005) {
            console.log(`📝 Form monitoring paused: ${deductionRules.reason}`);
          }
        }
      }
      
      // Step-off detection - detect when gymnast steps off mushroom
      detectStepOff(landmarks);
      
      // Step detection during landing - check for illegal steps after landing
      detectStepsInLanding(landmarks);
      
      // Circle detection - track completed circles during routine
      detectCircles(landmarks);
    }

    function detectStepOff(landmarks) {
      if (routineState !== ROUTINE_STATES.ACTIVE || hasSteppedOff) return;
      
      // Calculate current body center using hips and feet
      const leftHip = landmarks[23];
      const rightHip = landmarks[24];
      const leftAnkle = landmarks[27];
      const rightAnkle = landmarks[28];
      
      if (!leftHip || !rightHip || !leftAnkle || !rightAnkle) {
        return;
      }
      
      // Current body center X position (average of hips and feet)
      const hipCenterX = (leftHip.x + rightHip.x) / 2;
      const ankleCenterX = (leftAnkle.x + rightAnkle.x) / 2;
      const currentCenterX = (hipCenterX + ankleCenterX) / 2;
      
      const now = performance.now();
      const routineTime = (now - routineStartTime) / 1000;
      
      // Establish baseline center position during the first 10 seconds of routine
      if (routineTime <= 10) {
        if (baselineCenterX === null) {
          baselineCenterX = currentCenterX;
          console.log(`📍 Baseline center position established: ${baselineCenterX.toFixed(3)}`);
        } else {
          // Update baseline with moving average for stability
          baselineCenterX = (baselineCenterX * 0.95) + (currentCenterX * 0.05);
        }
        return;
      }
      
      // After 10 seconds, check for significant horizontal movement (stepping off to side)
      // Account for hand releases during circles - this is normal pommel horse technique
      if (baselineCenterX !== null && !hasSteppedOff) {
        const horizontalShift = Math.abs(currentCenterX - baselineCenterX);
        const shiftThreshold = 0.35; // Higher threshold - hand releases cause major shifts
        
        // Additional check: are feet on ground? Real dismount = feet touch ground
        const hipY = (leftHip.y + rightHip.y) / 2;
        const ankleY = (leftAnkle.y + rightAnkle.y) / 2;
        const legLength = ankleY - hipY;
        const feetOnGround = legLength > 0.2; // Generous threshold for ground contact
        
        // For fast pommel horse circles: detect sustained ground contact, not time-based
        if (horizontalShift > shiftThreshold && feetOnGround) {
          // Track consecutive frames with both conditions met
          if (!window.dismountFrameCount) {
            window.dismountFrameCount = 1;
            console.log(`🕰️ Potential dismount detected (shift: ${(horizontalShift*100).toFixed(1)}%, feet down), counting frames...`);
          } else {
            window.dismountFrameCount++;
            
            // Need 15 consecutive frames (about 1 second at 15fps) of sustained contact
            if (window.dismountFrameCount >= 15) {
              hasSteppedOff = true;
              stepOffGracePeriod = now + 5000; // 5 second grace period for landing/bow sequence
              window.dismountFrameCount = 0;
              
              // Record landing position for step detection
              landingPosition = {
                x: currentCenterX,
                y: (hipCenterX + ankleCenterX) / 2,
                time: now
              };
              
              console.log(`🚁 CONFIRMED DISMOUNT! ${window.dismountFrameCount} frames of sustained ground contact - starting landing grace period`);
              console.log(`Dismount detected at ${routineTime.toFixed(1)}s into routine`);
            }
          }
        } else {
          // Reset frame counter if conditions not met
          if (window.dismountFrameCount > 0) {
            const reason = !feetOnGround ? 'feet airborne again' : 'back near baseline';
            console.log(`🔙 Dismount cancelled after ${window.dismountFrameCount} frames - ${reason}`);
            window.dismountFrameCount = 0;
          }
        }
      }
    }
    
    function detectStepsInLanding(landmarks) {
      // Only check for steps during step-off grace period (when landed)
      if (!hasSteppedOff || routineState !== ROUTINE_STATES.ACTIVE) return;
      if (!landingPosition) return;
      
      const now = performance.now();
      
      // Only check every 200ms to avoid excessive detection
      if (now - lastStepCheckTime < 200) return;
      lastStepCheckTime = now;
      
      // Calculate current position
      const leftHip = landmarks[23];
      const rightHip = landmarks[24];
      const leftAnkle = landmarks[27];
      const rightAnkle = landmarks[28];
      
      if (!leftHip || !rightHip || !leftAnkle || !rightAnkle) {
        return;
      }
      
      const hipCenterX = (leftHip.x + rightHip.x) / 2;
      const ankleCenterX = (leftAnkle.x + rightAnkle.x) / 2;
      const currentCenterX = (hipCenterX + ankleCenterX) / 2;
      const currentCenterY = (((leftHip.y + rightHip.y) / 2) + ((leftAnkle.y + rightAnkle.y) / 2)) / 2;
      
      // Calculate movement from landing position
      const moveX = Math.abs(currentCenterX - landingPosition.x);
      const moveY = Math.abs(currentCenterY - landingPosition.y);
      const totalMovement = Math.sqrt(moveX * moveX + moveY * moveY);
      
      // Step threshold - significant movement after landing
      const stepThreshold = 0.08; // Adjust based on testing
      
      // Evaluate step severity and apply realistic deductions
      const stepSeverity = evaluateStepSeverity(totalMovement);
      
      if (stepSeverity > 0) {
        // Allow small adjustments in first 1 second after landing
        const timeSinceLanding = (now - landingPosition.time) / 1000;
        if (timeSinceLanding > 1.0) {
          // Count this step and apply deduction
          const stepCount = (window.stepCount || 0) + 1;
          window.stepCount = stepCount;
          
          console.log(`👣 STEP ${stepCount} DETECTED! Moved ${(totalMovement * 100).toFixed(1)}% - Severity: ${stepSeverity}`);
          applyStepDeduction(stepSeverity, stepCount);
          
          // Update landing position to prevent repeated deductions for same step sequence
          landingPosition.x = currentCenterX;
          landingPosition.y = currentCenterY;
          landingPosition.time = now;
        }
      }
    }
    
    function detectCircles(landmarks) {
      if (routineState !== ROUTINE_STATES.ACTIVE) return;
      if (!hasEverBeenAirborne) return; // Only count circles during routine, not mounting
      
      // Movement-based circle detection: track body rotation over time
      const leftHip = landmarks[23], rightHip = landmarks[24];
      const leftAnkle = landmarks[27], rightAnkle = landmarks[28];
      
      if (!leftHip || !rightHip || !leftAnkle || !rightAnkle) return;
      
      const now = performance.now();
      
      // Calculate current body center and angle
      const hipCenterX = (leftHip.x + rightHip.x) / 2;
      const ankleCenterX = (leftAnkle.x + rightAnkle.x) / 2;
      const bodyX = (hipCenterX + ankleCenterX) / 2;
      const bodyY = (((leftHip.y + rightHip.y) / 2) + ((leftAnkle.y + rightAnkle.y) / 2)) / 2;
      
      // Initialize circle state tracking
      if (window.circleDetectionState === undefined) {
        window.circleDetectionState = {
          lastBodyX: bodyX,
          lastBodyY: bodyY,
          lastUpdateTime: now,
          movementHistory: [],
          circleStartTime: 0,
          lastCircleTime: 0
        };
        console.log(`🎯 Circle detection initialized - Movement-based tracking`);
      }
      
      const state = window.circleDetectionState;
      
      // Only update every 200ms to avoid noise
      if (now - state.lastUpdateTime > 200) {
        const moveX = bodyX - state.lastBodyX;
        const moveY = bodyY - state.lastBodyY;
        const distance = Math.sqrt(moveX * moveX + moveY * moveY);
        
        // Track movement if significant
        if (distance > 0.02) {
          state.movementHistory.push({
            x: bodyX,
            y: bodyY,
            time: now,
            moveX: moveX,
            moveY: moveY
          });
          
          // Keep only recent movements (last 4 seconds)
          state.movementHistory = state.movementHistory.filter(m => now - m.time < 4000);
          
          // Check for circular motion pattern
          if (state.movementHistory.length > 4) {
            const totalMoveX = state.movementHistory.reduce((sum, m) => sum + m.moveX, 0);
            const totalMoveY = state.movementHistory.reduce((sum, m) => sum + m.moveY, 0);
            const totalDistance = state.movementHistory.reduce((sum, m) => sum + Math.sqrt(m.moveX * m.moveX + m.moveY * m.moveY), 0);
            
            // Circle detected if:
            // 1. Net movement is small (returned to similar position)
            // 2. Total distance traveled is significant (moved around)
            const netMovement = Math.sqrt(totalMoveX * totalMoveX + totalMoveY * totalMoveY);
            
            if (netMovement < 0.20 && totalDistance > 0.15) {
              circleCount++;
              state.lastCircleTime = now;
              state.movementHistory = []; // Reset for next circle
              
              console.log(`🎯 Circle ${circleCount} COMPLETED! Net movement: ${netMovement.toFixed(3)}, Total distance: ${totalDistance.toFixed(3)}`);
              
              // Apply deduction for completed circle
              applyCircleDeduction(circleCount, currentCircleWorstBending, currentCircleWorstSpreading);
              
              // Reset for next circle
              currentCircleWorstBending = 0;
              currentCircleWorstSpreading = 0;
              currentCircleStartTime = now;
              
              // Update display
              circleCountDisplay.textContent = `Circles: ${circleCount.toFixed(2)}`;
            }
            
            // Debug circle detection occasionally
            if (Math.random() < 0.02) {
              console.log(`🔄 Circle check - Net: ${netMovement.toFixed(3)}, Total: ${totalDistance.toFixed(3)}`);
            }
          }
        }
        
        state.lastBodyX = bodyX;
        state.lastBodyY = bodyY;
        state.lastUpdateTime = now;
      }
    }
    
    function applyCircleDeduction(circleNumber, bendingSeverity, spreadingSeverity) {
      // Apply single deduction for completed circle based on worst mistake
      const worstMistake = Math.max(bendingSeverity, spreadingSeverity);
      
      if (worstMistake === 0) {
        console.log(`✨ Circle ${circleNumber} completed with perfect form - no deduction`);
        return;
      }
      
      const now = performance.now();
      const videoTime = (now - routineStartTime) / 1000;
      
      // Apply the deduction
      score = Math.max(5.0, score - worstMistake);
      
      // Create descriptive reason
      let reason = `Circle ${circleNumber}: `;
      if (worstMistake === 0.1) reason += "Minor form break";
      else if (worstMistake === 0.2) reason += "Moderate form break";
      else reason += "Major form break";
      
      if (bendingSeverity > 0 && spreadingSeverity > 0) {
        reason += " (bending + spreading)";
      } else if (bendingSeverity > 0) {
        reason += " (leg bending)";
      } else {
        reason += " (legs spread)";
      }
      
      console.log(`🔄 CIRCLE ${circleNumber} COMPLETE: Deduction -${worstMistake} (${reason}) - Score: ${score.toFixed(1)}`);
      
      // Record for replay - but don't pause at circle completion, pause happened during mistake
      circleDeductions.push({
        circleNumber: circleNumber,
        deduction: worstMistake,
        reason: reason,
        time: videoTime,
        score: score.toFixed(1)
      });
      
      // Don't update score display during routine - scores only shown during replay
    }
    
    function applyStepDeduction(stepSeverity, stepNumber) {
      // Apply immediate deduction for each step after landing
      if (stepSeverity === 0) return;
      
      const now = performance.now();
      const videoTime = (now - routineStartTime) / 1000;
      
      // Apply the deduction
      score = Math.max(5.0, score - stepSeverity);
      
      // Create descriptive reason
      let reason = `Step ${stepNumber}: `;
      if (stepSeverity === 0.1) reason += "Small step";
      else if (stepSeverity === 0.2) reason += "Medium step";
      else reason += "Large step";
      
      console.log(`👣 STEP DEDUCTION: -${stepSeverity} (${reason}) - Score: ${score.toFixed(1)}`);
      
      // Record timestamp for replay pausing
      deductionTimestamps.push({
        time: videoTime,
        reason: reason,
        score: score.toFixed(1)
      });
      
      // Don't update score display during routine - scores only shown during replay
    }
    
    function recordMistakeForReplay(mistakeType, severity) {
      // Record mistake timestamp for replay pausing (but don't deduct yet for circles)
      if (severity === 0) return;
      
      const now = performance.now();
      const videoTime = (now - routineStartTime) / 1000;
      
      let reason = "";
      if (mistakeType === "bending") {
        if (severity === 0.1) reason = "Minor leg bending";
        else if (severity === 0.2) reason = "Moderate leg bending";
        else reason = "Major leg bending";
      } else if (mistakeType === "spreading") {
        if (severity === 0.1) reason = "Minor leg spreading";
        else if (severity === 0.2) reason = "Moderate leg spreading";
        else reason = "Major leg spreading";
      }
      
      // Only record if this is worse than what we've seen or it's been a while
      const lastMistake = deductionTimestamps[deductionTimestamps.length - 1];
      if (!lastMistake || (videoTime - lastMistake.time) > 2.0) {
        // Record for replay pausing - but note this doesn't deduct points yet
        deductionTimestamps.push({
          time: videoTime,
          reason: reason + " (will be scored at end of circle)",
          score: "Pending"
        });
        
        console.log(`🎥 Mistake recorded for replay: ${reason} at ${videoTime.toFixed(1)}s`);
      }
    }
    
    function startRoutineAutomatically() {
      if (!mediaStream) return;
      // Transition to ACTIVE state - deductions now enabled
      routineState = ROUTINE_STATES.ACTIVE;
      routineStarted = true;
      waitingForSalute = false;
      waitingForBow = true;
      gestureHoldFrames = 0;
      
      console.log('Routine state: SETUP → ACTIVE (deductions enabled)');
      
      startBtn.disabled = true;
      
      // Reset score & tracking
      score = 10.0;
      deductionTimestamps = []; // Reset deduction timestamps
      
      // Hide score during routine - will be revealed during replay
      scoreDisplay.parentElement.style.display = 'none';
      scoreDisplay.textContent = score.toFixed(1);
      
      // Record routine start time for video timing
      routineStartTime = performance.now();
      // No time-based grace period - use visibility-based mounting detection instead
      
      // Reset step-off detection
      baselineCenterX = null;
      stepOffGracePeriod = 0;
      hasSteppedOff = false;
      window.dismountFrameCount = 0;
      
      // Reset landing step detection
      landingPosition = null;
      lastStepCheckTime = 0;
      
      // Reset circle detection (new visibility-based system)
      circleCount = 0;
      circleCountDisplay.textContent = 'Circles: 0.00';
      window.circleDetectionState = undefined; // Reset visibility tracking
      
      // Reset ground contact tracking
      hasEverBeenAirborne = false;
      currentlyGrounded = true;
      lastGroundCheckTime = 0;
      
      // Reset circle-based deduction tracking
      currentCircleStartTime = routineStartTime;
      currentCircleWorstBending = 0;
      currentCircleWorstSpreading = 0;
      currentCircleDeductionApplied = false;
      circleDeductions = [];
      window.stepCount = 0; // Reset step counter
      
      console.log('Routine start time recorded for video timing');
      console.log('Realistic circle-based deduction system initialized');
      
      // Setup MediaRecorder
      recordedChunks = []; // Clear previous recording
      
      mediaRecorder = new MediaRecorder(mediaStream, { mimeType: "video/webm" });
      mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
      mediaRecorder.onstop = () => {
        // Store video blob for replay instead of downloading
        recordedVideoBlob = new Blob(recordedChunks, { type: "video/webm" });
        console.log('Video recorded, starting replay system');
        startReplay();
      };
      mediaRecorder.start();
      
      poseStatus.textContent = 'Routine Started - Tracking Performance';
      poseStatus.style.color = '#ff9800';
    }
    
    function endRoutineAutomatically() {
      if (mediaRecorder && mediaRecorder.state === "recording") mediaRecorder.stop();
      
      // Transition to FINISHED state - deductions now disabled
      routineState = ROUTINE_STATES.FINISHED;
      routineStarted = false;
      waitingForBow = false;
      waitingForSalute = false;
      gestureHoldFrames = 0;
      
      console.log('Routine state: ACTIVE → FINISHED (deductions disabled)');
      
      // Return to WAITING state - ready for next routine
      routineState = ROUTINE_STATES.WAITING;
      startBtn.disabled = false;
      startBtn.textContent = 'Ready for Routine';
      
      console.log('Routine state: FINISHED → WAITING (ready for next routine)');
      
      poseStatus.textContent = 'Routine Complete - Ready for Next';
      poseStatus.style.color = '#4caf50';
      
      // Show score display when routine ends
      scoreDisplay.parentElement.style.display = 'block';
      scoreDisplay.textContent = score.toFixed(1);
      
      // Don't show alert immediately - replay will handle this
      console.log(`Routine complete! Final Score: ${score.toFixed(1)}`);
    }
    
    function startReplay() {
      // Show replay video overlay
      replaySection.style.display = 'block';
      replayStatus.style.display = 'block';
      
      // Show close button, hide start button
      document.getElementById('closeReplay').style.display = 'block';
      document.getElementById('startRoutine').style.display = 'none';
      
      // Set up video source
      const videoUrl = URL.createObjectURL(recordedVideoBlob);
      replayVideo.src = videoUrl;
      
      console.log(`Starting replay with ${deductionTimestamps.length} deductions to pause at:`, deductionTimestamps);
      
      // Start countdown
      let countdown = 3;
      replayStatus.textContent = `Replay starting in ${countdown} seconds...`;
      
      const countdownInterval = setInterval(() => {
        countdown--;
        if (countdown > 0) {
          replayStatus.textContent = `Replay starting in ${countdown} seconds...`;
        } else {
          clearInterval(countdownInterval);
          replayStatus.textContent = 'Playing routine - will pause at deductions';
          startVideoPlayback();
        }
      }, 1000);
    }
    
    function enableManualControls() {
      // Enable native HTML video controls
      replayVideo.controls = true;
      
      console.log('Native video controls enabled - you can now scrub through the video');
    }
    
    
    function startVideoPlayback() {
      let currentDeductionIndex = 0;
      let isPaused = false;
      
      replayVideo.play();
      
      // Define the deduction checking function so we can remove it later
      function checkForDeductions() {
        const currentTime = replayVideo.currentTime;
        
        // Check if we need to pause at a deduction
        if (!isPaused && currentDeductionIndex < deductionTimestamps.length) {
          const nextDeduction = deductionTimestamps[currentDeductionIndex];
          
          // Pause if we've reached or passed the deduction time
          if (currentTime >= nextDeduction.time) {
            isPaused = true;
            replayVideo.pause();
            
            replayStatus.textContent = `DEDUCTION: ${nextDeduction.reason} - Score: ${nextDeduction.score} (pausing 2 seconds)`;
            replayStatus.style.color = '#ff5722';
            replayStatus.style.display = 'block';
            
            console.log(`Paused at deduction ${currentDeductionIndex + 1}: ${nextDeduction.reason} at ${nextDeduction.time.toFixed(2)}s`);
            
            // Resume after 2 seconds
            setTimeout(() => {
              currentDeductionIndex++;
              isPaused = false;
              replayVideo.play();
              
              if (currentDeductionIndex < deductionTimestamps.length) {
                replayStatus.textContent = 'Playing routine - will pause at next deduction';
                replayStatus.style.display = 'block';
              } else {
                replayStatus.textContent = 'Playing routine - no more deductions';
                replayStatus.style.display = 'block';
              }
              replayStatus.style.color = '#ff9800';
              
              // Hide status after 2 more seconds during normal play
              setTimeout(() => {
                if (!isPaused) {
                  replayStatus.style.display = 'none';
                }
              }, 2000);
            }, 2000);
          }
        }
      }
      
      // Add the deduction checking event listener
      replayVideo.addEventListener('timeupdate', checkForDeductions);
      
      // Handle video end
      replayVideo.addEventListener('ended', () => {
        replayStatus.textContent = `Routine Complete! Final Score: ${score.toFixed(1)} - Use controls to review`;
        replayStatus.style.color = '#4caf50';
        replayStatus.style.display = 'block';
        console.log('Automatic replay finished - enabling manual controls');
        
        // Enable manual video controls
        enableManualControls();
        
        // Reset video to beginning for manual review
        replayVideo.currentTime = 0;
      });
    }

    // Start routine - now activates gesture detection mode
    startBtn.addEventListener('click', () => {
      if (!mediaStream) return alert("Camera not ready yet");

      // Transition to SETUP state - waiting for salute (no deductions yet)
      routineState = ROUTINE_STATES.SETUP;
      waitingForSalute = true;
      waitingForBow = false;
      gestureHoldFrames = 0;
      
      // Reset salute detection
      
      console.log('Routine state: WAITING → SETUP (waiting for salute, no deductions)');
      
      startBtn.textContent = 'Waiting for Salute...';
      startBtn.disabled = true;
      
      poseStatus.textContent = 'Ready - Waiting for Salute';
      poseStatus.style.color = '#ff9800';
      
      console.log('Gesture detection activated - raise one arm to salute and start routine');
      // Pose detection is already running continuously
    });

    // Manual end button removed - using automatic bow detection only

    // Clear log functionality removed - using video replay instead
    
    // Debug skeleton functionality removed
    
    // Close replay and reset for next routine
    closeReplayBtn.addEventListener('click', () => {
      // Hide replay overlay
      replaySection.style.display = 'none';
      replayStatus.style.display = 'none';
      
      // Show start button, hide close button
      document.getElementById('startRoutine').style.display = 'block';
      document.getElementById('closeReplay').style.display = 'none';
      
      // Stop video and clean up
      replayVideo.pause();
      replayVideo.controls = false; // Disable native controls
      if (replayVideo.src) {
        URL.revokeObjectURL(replayVideo.src);
      }
      replayVideo.src = '';
      
      // Reset for next routine
      routineState = ROUTINE_STATES.WAITING;
      startBtn.disabled = false;
      startBtn.textContent = 'Ready for Routine';
      
      // Reset score for next person and show score display
      score = 10.0;
      scoreDisplay.parentElement.style.display = 'block';
      scoreDisplay.textContent = score.toFixed(1);
      
      // Clear recorded data
      recordedVideoBlob = null;
      deductionTimestamps = [];
      recordedChunks = [];
      mountingGracePeriod = 0;
      circleCount = 0; // Reset circle count for next routine
      
      // Reset step-off detection variables
      baselineCenterX = null;
      stepOffGracePeriod = 0;
      hasSteppedOff = false;
      window.dismountFrameCount = 0;
      
      // Reset landing step detection variables
      landingPosition = null;
      lastStepCheckTime = 0;
      
      // Reset circle detection variables (new visibility-based system)
      circleCountDisplay.textContent = 'Circles: 0.00';
      window.circleDetectionState = undefined; // Reset visibility tracking
      
      // Reset circle-based deduction tracking
      currentCircleStartTime = 0;
      currentCircleWorstBending = 0;
      currentCircleWorstSpreading = 0;
      currentCircleDeductionApplied = false;
      circleDeductions = [];
      window.stepCount = 0;
      
      poseStatus.textContent = 'Ready for Next Routine - Score Reset';
      poseStatus.style.color = '#4caf50';
      
      console.log('Replay closed, ready for next routine');
    });
    
  </script>
</body>
</html>
