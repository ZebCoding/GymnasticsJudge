<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gymnastics Judge AI</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; text-align: center; background: #111; color: white; }
    video { width: 100%; max-width: 480px; border: 2px solid #444; border-radius: 12px; margin-top: 10px; }
    canvas { display: none; }
    .score { font-size: 2em; margin: 20px 0; }
    button { padding: 12px 20px; margin: 10px; font-size: 1em; border: none; border-radius: 8px; background: #007BFF; color: white; }
    button:hover { background: #0056b3; }
    button:disabled { background: #555; }
  </style>
  <!-- Load MediaPipe Pose -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</head>
<body>
  <h1>Gymnastics Judge AI</h1>
  <video id="camera" autoplay playsinline></video>
  <canvas id="snapshot"></canvas>
  <div class="score">Score: <span id="score">10.0</span></div>
  <div id="poseStatus" style="color: #888; font-size: 0.9em; margin: 10px 0;">Pose: Not detecting</div>

  <button id="startRoutine">Start Routine</button>
  <button id="endRoutine" disabled>End Routine</button>
  <button id="viewDeductions" onclick="location.href='deductions.html'">View Deductions</button>
  <button id="clearLog">Clear Log</button>

  <script>
    const video = document.getElementById('camera');
    const canvas = document.getElementById('snapshot');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('score');
    const poseStatus = document.getElementById('poseStatus');

    const startBtn = document.getElementById('startRoutine');
    const endBtn = document.getElementById('endRoutine');
    const clearLogBtn = document.getElementById('clearLog');

    let score = 10.0;
    let deductions = [];
    let mediaStream;
    let mediaRecorder;
    let recordedChunks = [];
    let routineStarted = false;

    // Control repeated deductions: per-reason cooldown in milliseconds
    const DEDUCTION_COOLDOWN_MS = 1500;
    let lastDeductionAt = {}; // reason -> timestamp (performance.now())

    // Get camera
    navigator.mediaDevices.getUserMedia({ video: true })
      .then(stream => { mediaStream = stream; video.srcObject = stream; })
      .catch(err => { alert('Camera not available: ' + err); });

    // Utility functions
    function calculateAngle(A, B, C) {
      const AB = {x: B.x - A.x, y: B.y - A.y};
      const CB = {x: B.x - C.x, y: B.y - C.y};
      const dot = AB.x * CB.x + AB.y * CB.y;
      const magAB = Math.sqrt(AB.x*AB.x + AB.y*AB.y);
      const magCB = Math.sqrt(CB.x*CB.x + CB.y*CB.y);
      const angle = Math.acos(dot / (magAB * magCB)) * (180/Math.PI);
      return angle;
    }

    function distance(A, B) {
      return Math.sqrt((A.x - B.x)**2 + (A.y - B.y)**2);
    }

    // Setup MediaPipe Pose
    const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/${file}`});
    pose.setOptions({modelComplexity: 1, smoothLandmarks: true, enableSegmentation: false});
    pose.onResults(onResults);

    async function detectPose() {
      if (!routineStarted) return;
      await pose.send({image: video});
      requestAnimationFrame(detectPose);
    }

    function onResults(results) {
      if (!results.poseLandmarks) {
        console.log('No pose landmarks detected');
        poseStatus.textContent = 'Pose: Not detected';
        poseStatus.style.color = '#888';
        return;
      }

      const landmarks = results.poseLandmarks;

      // Map keypoints
      const leftHip = landmarks[23], rightHip = landmarks[24];
      const leftKnee = landmarks[25], rightKnee = landmarks[26];
      const leftAnkle = landmarks[27], rightAnkle = landmarks[28];

      // Check if all required landmarks are visible (confidence > 0.5)
      const requiredLandmarks = [leftHip, rightHip, leftKnee, rightKnee, leftAnkle, rightAnkle];
      if (requiredLandmarks.some(landmark => !landmark || landmark.visibility < 0.5)) {
        console.log('Some required landmarks not visible or low confidence');
        poseStatus.textContent = 'Pose: Low confidence';
        poseStatus.style.color = '#ff9800';
        return;
      }

      // Good pose detection
      poseStatus.textContent = 'Pose: Tracking ✓';
      poseStatus.style.color = '#4caf50';

      // Knee angles
      const leftKneeAngle = calculateAngle(leftHip, leftKnee, leftAnkle);
      const rightKneeAngle = calculateAngle(rightHip, rightKnee, rightAnkle);
      const kneeThreshold = 160; // More sensitive - was 170

      // Debug measurements every 60 frames (~1 second at 60fps)
      if (Math.random() < 0.016) {
        console.log(`Measurements - Knee angles L:${leftKneeAngle.toFixed(1)}° R:${rightKneeAngle.toFixed(1)}°`);
        console.log(`Distances - Hips:${hipDistance.toFixed(3)} Ankles:${ankleDist.toFixed(3)} Knees:${kneeDist.toFixed(3)}`);
        console.log(`Ratios - Ankle/Hip:${(ankleDist/hipDistance).toFixed(2)} Knee/Hip:${(kneeDist/hipDistance).toFixed(2)}`);
      }

      // Body width measurements
      const hipDistance = distance(leftHip, rightHip);
      const ankleDist = distance(leftAnkle, rightAnkle);
      const kneeDist = distance(leftKnee, rightKnee);
      
      // More sensitive legs apart detection - multiple methods
      const maxAnkleDistFactor = 1.3; // was 1.5 - more strict
      const maxKneeDistFactor = 1.4;  // knee distance shouldn't exceed this either
      
      // Also check absolute distance (for very wide stances)
      const maxAbsoluteAnkleDist = 0.3; // normalized coordinate distance

      // Check deductions with debugging
      if (leftKneeAngle < kneeThreshold) {
        console.log(`Left leg bent detected: ${leftKneeAngle.toFixed(1)}° < ${kneeThreshold}°`);
        addDeduction("Left leg bent");
      }
      if (rightKneeAngle < kneeThreshold) {
        console.log(`Right leg bent detected: ${rightKneeAngle.toFixed(1)}° < ${kneeThreshold}°`);
        addDeduction("Right leg bent");
      }
      // Multiple checks for legs too far apart
      const ankleRatio = ankleDist / hipDistance;
      const kneeRatio = kneeDist / hipDistance;
      
      if (ankleRatio > maxAnkleDistFactor) {
        console.log(`Legs apart (ankle ratio): ${ankleRatio.toFixed(2)} > ${maxAnkleDistFactor}`);
        addDeduction("Legs too far apart");
      } else if (kneeRatio > maxKneeDistFactor) {
        console.log(`Legs apart (knee ratio): ${kneeRatio.toFixed(2)} > ${maxKneeDistFactor}`);
        addDeduction("Legs too far apart");
      } else if (ankleDist > maxAbsoluteAnkleDist) {
        console.log(`Legs apart (absolute): ${ankleDist.toFixed(3)} > ${maxAbsoluteAnkleDist}`);
        addDeduction("Legs too far apart");
      }
    }

    function addDeduction(reason) {
      // Allow repeated deductions for the same reason after a short cooldown
      const now = performance.now();
      const lastTime = lastDeductionAt[reason] || 0;
      if (now - lastTime < DEDUCTION_COOLDOWN_MS) {
        console.log(`Deduction "${reason}" blocked by cooldown (${((now - lastTime)/1000).toFixed(1)}s ago)`);
        return;
      }
      lastDeductionAt[reason] = now;

      score = Math.max(5.0, score - 0.2);
      console.log(`Deduction applied: "${reason}" - New score: ${score.toFixed(1)}`);

      // Snapshot
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      const imageData = canvas.toDataURL('image/png');

      const event = {
        time: new Date().toLocaleTimeString(),
        reason: reason,
        deduction: 0.2,
        remaining: score.toFixed(1),
        snapshot: imageData
      };
      deductions.push(event);
      scoreDisplay.textContent = score.toFixed(1);
      localStorage.setItem('deductionsLog', JSON.stringify(deductions));
    }

    // Start routine
    startBtn.addEventListener('click', () => {
      if (!mediaStream) return alert("Camera not ready yet");

      routineStarted = true;
      startBtn.disabled = true;
      endBtn.disabled = false;

      // Reset score & log
      score = 10.0;
      deductions = [];
      lastDeductionAt = {};
      scoreDisplay.textContent = score.toFixed(1);
      localStorage.removeItem('deductionsLog');

      // Setup MediaRecorder
      mediaRecorder = new MediaRecorder(mediaStream, { mimeType: "video/webm" });
      mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
      mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: "video/webm" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `routine_${Date.now()}.webm`;
        a.click();
        URL.revokeObjectURL(url);
        recordedChunks = [];
      };
      mediaRecorder.start();

      detectPose(); // start detection
    });

    // End routine
    endBtn.addEventListener('click', () => {
      if (mediaRecorder && mediaRecorder.state === "recording") mediaRecorder.stop();
      routineStarted = false;
      startBtn.disabled = false;
      endBtn.disabled = true;
      alert("Routine ended. Video saved. Ready for next routine.");
    });

    // Clear log
    clearLogBtn.addEventListener("click", () => {
      deductions = [];
      score = 10.0;
      scoreDisplay.textContent = score.toFixed(1);
      localStorage.removeItem('deductionsLog');
      alert("Log cleared, score reset.");
    });
  </script>
</body>
</html>
